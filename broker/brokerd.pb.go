// Code generated by protoc-gen-go. DO NOT EDIT.
// source: brokerd.proto

/*
Package brokerd is a generated protocol buffer package.

It is generated from these files:
	brokerd.proto

It has these top-level messages:
	Tenant
	TenantList
	Image
	Reference
	TenantName
	ImageList
	NetworkDefinition
	GatewayDefinition
	Network
	NetworkList
	VMDefinition
	VM
	VMList
	SshConfig
	VolumeDefinition
	Volume
	VolumeList
	VolumeAttachment
	VolumeDetachment
	Container
	ContainerList
	ContainerMountingPoint
	SshCommand
	SshCopyCommand
	SshResponse
*/
package brokerd

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/empty"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type VMState int32

const (
	// STOPPED VM is stopped
	VMState_STOPPED VMState = 0
	// STARTING VM is starting
	VMState_STARTING VMState = 1
	// STARTED VM is started
	VMState_STARTED VMState = 2
	// STOPPING VM is stopping
	VMState_STOPPING VMState = 3
	// ERROR VM is in error state
	VMState_ERROR VMState = 4
)

var VMState_name = map[int32]string{
	0: "STOPPED",
	1: "STARTING",
	2: "STARTED",
	3: "STOPPING",
	4: "ERROR",
}
var VMState_value = map[string]int32{
	"STOPPED":  0,
	"STARTING": 1,
	"STARTED":  2,
	"STOPPING": 3,
	"ERROR":    4,
}

func (x VMState) String() string {
	return proto.EnumName(VMState_name, int32(x))
}
func (VMState) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type VolumeSpeed int32

const (
	VolumeSpeed_COLD VolumeSpeed = 0
	VolumeSpeed_HDD  VolumeSpeed = 1
	VolumeSpeed_SSD  VolumeSpeed = 2
)

var VolumeSpeed_name = map[int32]string{
	0: "COLD",
	1: "HDD",
	2: "SSD",
}
var VolumeSpeed_value = map[string]int32{
	"COLD": 0,
	"HDD":  1,
	"SSD":  2,
}

func (x VolumeSpeed) String() string {
	return proto.EnumName(VolumeSpeed_name, int32(x))
}
func (VolumeSpeed) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type Tenant struct {
	Name     string `protobuf:"bytes,1,opt,name=Name,json=name" json:"Name,omitempty"`
	Provider string `protobuf:"bytes,2,opt,name=Provider,json=provider" json:"Provider,omitempty"`
}

func (m *Tenant) Reset()                    { *m = Tenant{} }
func (m *Tenant) String() string            { return proto.CompactTextString(m) }
func (*Tenant) ProtoMessage()               {}
func (*Tenant) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Tenant) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Tenant) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

type TenantList struct {
	Tenants []*Tenant `protobuf:"bytes,1,rep,name=Tenants,json=tenants" json:"Tenants,omitempty"`
}

func (m *TenantList) Reset()                    { *m = TenantList{} }
func (m *TenantList) String() string            { return proto.CompactTextString(m) }
func (*TenantList) ProtoMessage()               {}
func (*TenantList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *TenantList) GetTenants() []*Tenant {
	if m != nil {
		return m.Tenants
	}
	return nil
}

type Image struct {
	ID   string `protobuf:"bytes,1,opt,name=ID,json=iD" json:"ID,omitempty"`
	Name string `protobuf:"bytes,2,opt,name=Name,json=name" json:"Name,omitempty"`
}

func (m *Image) Reset()                    { *m = Image{} }
func (m *Image) String() string            { return proto.CompactTextString(m) }
func (*Image) ProtoMessage()               {}
func (*Image) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Image) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Image) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Reference struct {
	TenantID string `protobuf:"bytes,1,opt,name=TenantID,json=tenantID" json:"TenantID,omitempty"`
	ID       string `protobuf:"bytes,2,opt,name=ID,json=iD" json:"ID,omitempty"`
	Name     string `protobuf:"bytes,3,opt,name=Name,json=name" json:"Name,omitempty"`
}

func (m *Reference) Reset()                    { *m = Reference{} }
func (m *Reference) String() string            { return proto.CompactTextString(m) }
func (*Reference) ProtoMessage()               {}
func (*Reference) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Reference) GetTenantID() string {
	if m != nil {
		return m.TenantID
	}
	return ""
}

func (m *Reference) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Reference) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type TenantName struct {
	Name string `protobuf:"bytes,1,opt,name=Name,json=name" json:"Name,omitempty"`
}

func (m *TenantName) Reset()                    { *m = TenantName{} }
func (m *TenantName) String() string            { return proto.CompactTextString(m) }
func (*TenantName) ProtoMessage()               {}
func (*TenantName) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *TenantName) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type ImageList struct {
	Images []*Image `protobuf:"bytes,1,rep,name=Images,json=images" json:"Images,omitempty"`
}

func (m *ImageList) Reset()                    { *m = ImageList{} }
func (m *ImageList) String() string            { return proto.CompactTextString(m) }
func (*ImageList) ProtoMessage()               {}
func (*ImageList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ImageList) GetImages() []*Image {
	if m != nil {
		return m.Images
	}
	return nil
}

type NetworkDefinition struct {
	Name    string             `protobuf:"bytes,2,opt,name=Name,json=name" json:"Name,omitempty"`
	CIDR    string             `protobuf:"bytes,3,opt,name=CIDR,json=cIDR" json:"CIDR,omitempty"`
	Gateway *GatewayDefinition `protobuf:"bytes,4,opt,name=Gateway,json=gateway" json:"Gateway,omitempty"`
}

func (m *NetworkDefinition) Reset()                    { *m = NetworkDefinition{} }
func (m *NetworkDefinition) String() string            { return proto.CompactTextString(m) }
func (*NetworkDefinition) ProtoMessage()               {}
func (*NetworkDefinition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *NetworkDefinition) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NetworkDefinition) GetCIDR() string {
	if m != nil {
		return m.CIDR
	}
	return ""
}

func (m *NetworkDefinition) GetGateway() *GatewayDefinition {
	if m != nil {
		return m.Gateway
	}
	return nil
}

type GatewayDefinition struct {
	CPU     int32   `protobuf:"varint,1,opt,name=CPU,json=cPU" json:"CPU,omitempty"`
	RAM     float32 `protobuf:"fixed32,2,opt,name=RAM,json=rAM" json:"RAM,omitempty"`
	Disk    int32   `protobuf:"varint,3,opt,name=Disk,json=disk" json:"Disk,omitempty"`
	ImageID string  `protobuf:"bytes,5,opt,name=ImageID,json=imageID" json:"ImageID,omitempty"`
}

func (m *GatewayDefinition) Reset()                    { *m = GatewayDefinition{} }
func (m *GatewayDefinition) String() string            { return proto.CompactTextString(m) }
func (*GatewayDefinition) ProtoMessage()               {}
func (*GatewayDefinition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *GatewayDefinition) GetCPU() int32 {
	if m != nil {
		return m.CPU
	}
	return 0
}

func (m *GatewayDefinition) GetRAM() float32 {
	if m != nil {
		return m.RAM
	}
	return 0
}

func (m *GatewayDefinition) GetDisk() int32 {
	if m != nil {
		return m.Disk
	}
	return 0
}

func (m *GatewayDefinition) GetImageID() string {
	if m != nil {
		return m.ImageID
	}
	return ""
}

type Network struct {
	ID   string `protobuf:"bytes,1,opt,name=ID,json=iD" json:"ID,omitempty"`
	Name string `protobuf:"bytes,2,opt,name=Name,json=name" json:"Name,omitempty"`
	CIDR string `protobuf:"bytes,3,opt,name=CIDR,json=cIDR" json:"CIDR,omitempty"`
}

func (m *Network) Reset()                    { *m = Network{} }
func (m *Network) String() string            { return proto.CompactTextString(m) }
func (*Network) ProtoMessage()               {}
func (*Network) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *Network) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Network) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Network) GetCIDR() string {
	if m != nil {
		return m.CIDR
	}
	return ""
}

type NetworkList struct {
	Networks []*Network `protobuf:"bytes,1,rep,name=Networks,json=networks" json:"Networks,omitempty"`
}

func (m *NetworkList) Reset()                    { *m = NetworkList{} }
func (m *NetworkList) String() string            { return proto.CompactTextString(m) }
func (*NetworkList) ProtoMessage()               {}
func (*NetworkList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *NetworkList) GetNetworks() []*Network {
	if m != nil {
		return m.Networks
	}
	return nil
}

type VMDefinition struct {
	Name      string  `protobuf:"bytes,2,opt,name=Name,json=name" json:"Name,omitempty"`
	Network   string  `protobuf:"bytes,3,opt,name=Network,json=network" json:"Network,omitempty"`
	CPUNumber int32   `protobuf:"varint,4,opt,name=CPUNumber,json=cPUNumber" json:"CPUNumber,omitempty"`
	RAM       float32 `protobuf:"fixed32,6,opt,name=RAM,json=rAM" json:"RAM,omitempty"`
	Disk      int32   `protobuf:"varint,7,opt,name=Disk,json=disk" json:"Disk,omitempty"`
	ImageID   string  `protobuf:"bytes,9,opt,name=ImageID,json=imageID" json:"ImageID,omitempty"`
	Public    bool    `protobuf:"varint,10,opt,name=Public,json=public" json:"Public,omitempty"`
}

func (m *VMDefinition) Reset()                    { *m = VMDefinition{} }
func (m *VMDefinition) String() string            { return proto.CompactTextString(m) }
func (*VMDefinition) ProtoMessage()               {}
func (*VMDefinition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *VMDefinition) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *VMDefinition) GetNetwork() string {
	if m != nil {
		return m.Network
	}
	return ""
}

func (m *VMDefinition) GetCPUNumber() int32 {
	if m != nil {
		return m.CPUNumber
	}
	return 0
}

func (m *VMDefinition) GetRAM() float32 {
	if m != nil {
		return m.RAM
	}
	return 0
}

func (m *VMDefinition) GetDisk() int32 {
	if m != nil {
		return m.Disk
	}
	return 0
}

func (m *VMDefinition) GetImageID() string {
	if m != nil {
		return m.ImageID
	}
	return ""
}

func (m *VMDefinition) GetPublic() bool {
	if m != nil {
		return m.Public
	}
	return false
}

type VM struct {
	ID         string  `protobuf:"bytes,1,opt,name=ID,json=iD" json:"ID,omitempty"`
	Name       string  `protobuf:"bytes,2,opt,name=Name,json=name" json:"Name,omitempty"`
	CPU        int32   `protobuf:"varint,3,opt,name=CPU,json=cPU" json:"CPU,omitempty"`
	RAM        float32 `protobuf:"fixed32,4,opt,name=RAM,json=rAM" json:"RAM,omitempty"`
	Disk       int32   `protobuf:"varint,5,opt,name=Disk,json=disk" json:"Disk,omitempty"`
	IP         string  `protobuf:"bytes,6,opt,name=IP,json=iP" json:"IP,omitempty"`
	State      VMState `protobuf:"varint,8,opt,name=State,json=state,enum=VMState" json:"State,omitempty"`
	PrivateKey string  `protobuf:"bytes,9,opt,name=PrivateKey,json=privateKey" json:"PrivateKey,omitempty"`
	GatewayID  string  `protobuf:"bytes,10,opt,name=GatewayID,json=gatewayID" json:"GatewayID,omitempty"`
}

func (m *VM) Reset()                    { *m = VM{} }
func (m *VM) String() string            { return proto.CompactTextString(m) }
func (*VM) ProtoMessage()               {}
func (*VM) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *VM) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *VM) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *VM) GetCPU() int32 {
	if m != nil {
		return m.CPU
	}
	return 0
}

func (m *VM) GetRAM() float32 {
	if m != nil {
		return m.RAM
	}
	return 0
}

func (m *VM) GetDisk() int32 {
	if m != nil {
		return m.Disk
	}
	return 0
}

func (m *VM) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

func (m *VM) GetState() VMState {
	if m != nil {
		return m.State
	}
	return VMState_STOPPED
}

func (m *VM) GetPrivateKey() string {
	if m != nil {
		return m.PrivateKey
	}
	return ""
}

func (m *VM) GetGatewayID() string {
	if m != nil {
		return m.GatewayID
	}
	return ""
}

type VMList struct {
	VMs []*VM `protobuf:"bytes,1,rep,name=VMs,json=vMs" json:"VMs,omitempty"`
}

func (m *VMList) Reset()                    { *m = VMList{} }
func (m *VMList) String() string            { return proto.CompactTextString(m) }
func (*VMList) ProtoMessage()               {}
func (*VMList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *VMList) GetVMs() []*VM {
	if m != nil {
		return m.VMs
	}
	return nil
}

type SshConfig struct {
	User       string     `protobuf:"bytes,1,opt,name=User,json=user" json:"User,omitempty"`
	Host       string     `protobuf:"bytes,2,opt,name=Host,json=host" json:"Host,omitempty"`
	PrivateKey string     `protobuf:"bytes,3,opt,name=PrivateKey,json=privateKey" json:"PrivateKey,omitempty"`
	Port       int32      `protobuf:"varint,4,opt,name=Port,json=port" json:"Port,omitempty"`
	Gateway    *SshConfig `protobuf:"bytes,5,opt,name=gateway" json:"gateway,omitempty"`
}

func (m *SshConfig) Reset()                    { *m = SshConfig{} }
func (m *SshConfig) String() string            { return proto.CompactTextString(m) }
func (*SshConfig) ProtoMessage()               {}
func (*SshConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *SshConfig) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *SshConfig) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *SshConfig) GetPrivateKey() string {
	if m != nil {
		return m.PrivateKey
	}
	return ""
}

func (m *SshConfig) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *SshConfig) GetGateway() *SshConfig {
	if m != nil {
		return m.Gateway
	}
	return nil
}

type VolumeDefinition struct {
	Name  string      `protobuf:"bytes,2,opt,name=Name,json=name" json:"Name,omitempty"`
	Speed VolumeSpeed `protobuf:"varint,3,opt,name=Speed,json=speed,enum=VolumeSpeed" json:"Speed,omitempty"`
	Size  int32       `protobuf:"varint,4,opt,name=Size,json=size" json:"Size,omitempty"`
}

func (m *VolumeDefinition) Reset()                    { *m = VolumeDefinition{} }
func (m *VolumeDefinition) String() string            { return proto.CompactTextString(m) }
func (*VolumeDefinition) ProtoMessage()               {}
func (*VolumeDefinition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *VolumeDefinition) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *VolumeDefinition) GetSpeed() VolumeSpeed {
	if m != nil {
		return m.Speed
	}
	return VolumeSpeed_COLD
}

func (m *VolumeDefinition) GetSize() int32 {
	if m != nil {
		return m.Size
	}
	return 0
}

type Volume struct {
	ID    string      `protobuf:"bytes,1,opt,name=ID,json=iD" json:"ID,omitempty"`
	Name  string      `protobuf:"bytes,2,opt,name=Name,json=name" json:"Name,omitempty"`
	Speed VolumeSpeed `protobuf:"varint,3,opt,name=Speed,json=speed,enum=VolumeSpeed" json:"Speed,omitempty"`
	Size  int32       `protobuf:"varint,4,opt,name=Size,json=size" json:"Size,omitempty"`
}

func (m *Volume) Reset()                    { *m = Volume{} }
func (m *Volume) String() string            { return proto.CompactTextString(m) }
func (*Volume) ProtoMessage()               {}
func (*Volume) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *Volume) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Volume) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Volume) GetSpeed() VolumeSpeed {
	if m != nil {
		return m.Speed
	}
	return VolumeSpeed_COLD
}

func (m *Volume) GetSize() int32 {
	if m != nil {
		return m.Size
	}
	return 0
}

type VolumeList struct {
	Volumes []*Volume `protobuf:"bytes,1,rep,name=volumes" json:"volumes,omitempty"`
}

func (m *VolumeList) Reset()                    { *m = VolumeList{} }
func (m *VolumeList) String() string            { return proto.CompactTextString(m) }
func (*VolumeList) ProtoMessage()               {}
func (*VolumeList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *VolumeList) GetVolumes() []*Volume {
	if m != nil {
		return m.Volumes
	}
	return nil
}

type VolumeAttachment struct {
	Volume    *Reference `protobuf:"bytes,2,opt,name=Volume,json=volume" json:"Volume,omitempty"`
	VM        *Reference `protobuf:"bytes,3,opt,name=VM,json=vM" json:"VM,omitempty"`
	MountPath string     `protobuf:"bytes,4,opt,name=MountPath,json=mountPath" json:"MountPath,omitempty"`
	Format    string     `protobuf:"bytes,5,opt,name=Format,json=format" json:"Format,omitempty"`
}

func (m *VolumeAttachment) Reset()                    { *m = VolumeAttachment{} }
func (m *VolumeAttachment) String() string            { return proto.CompactTextString(m) }
func (*VolumeAttachment) ProtoMessage()               {}
func (*VolumeAttachment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *VolumeAttachment) GetVolume() *Reference {
	if m != nil {
		return m.Volume
	}
	return nil
}

func (m *VolumeAttachment) GetVM() *Reference {
	if m != nil {
		return m.VM
	}
	return nil
}

func (m *VolumeAttachment) GetMountPath() string {
	if m != nil {
		return m.MountPath
	}
	return ""
}

func (m *VolumeAttachment) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

type VolumeDetachment struct {
	Volume *Reference `protobuf:"bytes,1,opt,name=Volume,json=volume" json:"Volume,omitempty"`
	VM     *Reference `protobuf:"bytes,2,opt,name=VM,json=vM" json:"VM,omitempty"`
}

func (m *VolumeDetachment) Reset()                    { *m = VolumeDetachment{} }
func (m *VolumeDetachment) String() string            { return proto.CompactTextString(m) }
func (*VolumeDetachment) ProtoMessage()               {}
func (*VolumeDetachment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *VolumeDetachment) GetVolume() *Reference {
	if m != nil {
		return m.Volume
	}
	return nil
}

func (m *VolumeDetachment) GetVM() *Reference {
	if m != nil {
		return m.VM
	}
	return nil
}

type Container struct {
	Name string `protobuf:"bytes,2,opt,name=Name,json=name" json:"Name,omitempty"`
}

func (m *Container) Reset()                    { *m = Container{} }
func (m *Container) String() string            { return proto.CompactTextString(m) }
func (*Container) ProtoMessage()               {}
func (*Container) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *Container) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type ContainerList struct {
	Containers []*Container `protobuf:"bytes,1,rep,name=Containers,json=containers" json:"Containers,omitempty"`
}

func (m *ContainerList) Reset()                    { *m = ContainerList{} }
func (m *ContainerList) String() string            { return proto.CompactTextString(m) }
func (*ContainerList) ProtoMessage()               {}
func (*ContainerList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *ContainerList) GetContainers() []*Container {
	if m != nil {
		return m.Containers
	}
	return nil
}

type ContainerMountingPoint struct {
	Container string     `protobuf:"bytes,1,opt,name=Container,json=container" json:"Container,omitempty"`
	VM        *Reference `protobuf:"bytes,2,opt,name=VM,json=vM" json:"VM,omitempty"`
	Path      string     `protobuf:"bytes,3,opt,name=Path,json=path" json:"Path,omitempty"`
}

func (m *ContainerMountingPoint) Reset()                    { *m = ContainerMountingPoint{} }
func (m *ContainerMountingPoint) String() string            { return proto.CompactTextString(m) }
func (*ContainerMountingPoint) ProtoMessage()               {}
func (*ContainerMountingPoint) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *ContainerMountingPoint) GetContainer() string {
	if m != nil {
		return m.Container
	}
	return ""
}

func (m *ContainerMountingPoint) GetVM() *Reference {
	if m != nil {
		return m.VM
	}
	return nil
}

func (m *ContainerMountingPoint) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type SshCommand struct {
	VM      *Reference `protobuf:"bytes,1,opt,name=VM,json=vM" json:"VM,omitempty"`
	Command string     `protobuf:"bytes,2,opt,name=Command,json=command" json:"Command,omitempty"`
}

func (m *SshCommand) Reset()                    { *m = SshCommand{} }
func (m *SshCommand) String() string            { return proto.CompactTextString(m) }
func (*SshCommand) ProtoMessage()               {}
func (*SshCommand) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *SshCommand) GetVM() *Reference {
	if m != nil {
		return m.VM
	}
	return nil
}

func (m *SshCommand) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

type SshCopyCommand struct {
	Source      string `protobuf:"bytes,1,opt,name=Source,json=source" json:"Source,omitempty"`
	Destination string `protobuf:"bytes,2,opt,name=Destination,json=destination" json:"Destination,omitempty"`
}

func (m *SshCopyCommand) Reset()                    { *m = SshCopyCommand{} }
func (m *SshCopyCommand) String() string            { return proto.CompactTextString(m) }
func (*SshCopyCommand) ProtoMessage()               {}
func (*SshCopyCommand) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *SshCopyCommand) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *SshCopyCommand) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

type SshResponse struct {
	Output string `protobuf:"bytes,1,opt,name=output" json:"output,omitempty"`
	Err    string `protobuf:"bytes,2,opt,name=err" json:"err,omitempty"`
	Status int32  `protobuf:"varint,3,opt,name=status" json:"status,omitempty"`
}

func (m *SshResponse) Reset()                    { *m = SshResponse{} }
func (m *SshResponse) String() string            { return proto.CompactTextString(m) }
func (*SshResponse) ProtoMessage()               {}
func (*SshResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *SshResponse) GetOutput() string {
	if m != nil {
		return m.Output
	}
	return ""
}

func (m *SshResponse) GetErr() string {
	if m != nil {
		return m.Err
	}
	return ""
}

func (m *SshResponse) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func init() {
	proto.RegisterType((*Tenant)(nil), "Tenant")
	proto.RegisterType((*TenantList)(nil), "TenantList")
	proto.RegisterType((*Image)(nil), "Image")
	proto.RegisterType((*Reference)(nil), "Reference")
	proto.RegisterType((*TenantName)(nil), "TenantName")
	proto.RegisterType((*ImageList)(nil), "ImageList")
	proto.RegisterType((*NetworkDefinition)(nil), "NetworkDefinition")
	proto.RegisterType((*GatewayDefinition)(nil), "GatewayDefinition")
	proto.RegisterType((*Network)(nil), "Network")
	proto.RegisterType((*NetworkList)(nil), "NetworkList")
	proto.RegisterType((*VMDefinition)(nil), "VMDefinition")
	proto.RegisterType((*VM)(nil), "VM")
	proto.RegisterType((*VMList)(nil), "VMList")
	proto.RegisterType((*SshConfig)(nil), "SshConfig")
	proto.RegisterType((*VolumeDefinition)(nil), "VolumeDefinition")
	proto.RegisterType((*Volume)(nil), "Volume")
	proto.RegisterType((*VolumeList)(nil), "VolumeList")
	proto.RegisterType((*VolumeAttachment)(nil), "VolumeAttachment")
	proto.RegisterType((*VolumeDetachment)(nil), "VolumeDetachment")
	proto.RegisterType((*Container)(nil), "Container")
	proto.RegisterType((*ContainerList)(nil), "ContainerList")
	proto.RegisterType((*ContainerMountingPoint)(nil), "ContainerMountingPoint")
	proto.RegisterType((*SshCommand)(nil), "SshCommand")
	proto.RegisterType((*SshCopyCommand)(nil), "SshCopyCommand")
	proto.RegisterType((*SshResponse)(nil), "SshResponse")
	proto.RegisterEnum("VMState", VMState_name, VMState_value)
	proto.RegisterEnum("VolumeSpeed", VolumeSpeed_name, VolumeSpeed_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for TenantService service

type TenantServiceClient interface {
	List(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*TenantList, error)
	Reload(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	Set(ctx context.Context, in *TenantName, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	Get(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*TenantName, error)
}

type tenantServiceClient struct {
	cc *grpc.ClientConn
}

func NewTenantServiceClient(cc *grpc.ClientConn) TenantServiceClient {
	return &tenantServiceClient{cc}
}

func (c *tenantServiceClient) List(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*TenantList, error) {
	out := new(TenantList)
	err := grpc.Invoke(ctx, "/TenantService/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantServiceClient) Reload(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/TenantService/Reload", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantServiceClient) Set(ctx context.Context, in *TenantName, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/TenantService/Set", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantServiceClient) Get(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*TenantName, error) {
	out := new(TenantName)
	err := grpc.Invoke(ctx, "/TenantService/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TenantService service

type TenantServiceServer interface {
	List(context.Context, *google_protobuf.Empty) (*TenantList, error)
	Reload(context.Context, *google_protobuf.Empty) (*google_protobuf.Empty, error)
	Set(context.Context, *TenantName) (*google_protobuf.Empty, error)
	Get(context.Context, *google_protobuf.Empty) (*TenantName, error)
}

func RegisterTenantServiceServer(s *grpc.Server, srv TenantServiceServer) {
	s.RegisterService(&_TenantService_serviceDesc, srv)
}

func _TenantService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/TenantService/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServiceServer).List(ctx, req.(*google_protobuf.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantService_Reload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServiceServer).Reload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/TenantService/Reload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServiceServer).Reload(ctx, req.(*google_protobuf.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantService_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServiceServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/TenantService/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServiceServer).Set(ctx, req.(*TenantName))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/TenantService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServiceServer).Get(ctx, req.(*google_protobuf.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _TenantService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "TenantService",
	HandlerType: (*TenantServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _TenantService_List_Handler,
		},
		{
			MethodName: "Reload",
			Handler:    _TenantService_Reload_Handler,
		},
		{
			MethodName: "Set",
			Handler:    _TenantService_Set_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _TenantService_Get_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "brokerd.proto",
}

// Client API for ImageService service

type ImageServiceClient interface {
	List(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*ImageList, error)
}

type imageServiceClient struct {
	cc *grpc.ClientConn
}

func NewImageServiceClient(cc *grpc.ClientConn) ImageServiceClient {
	return &imageServiceClient{cc}
}

func (c *imageServiceClient) List(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*ImageList, error) {
	out := new(ImageList)
	err := grpc.Invoke(ctx, "/ImageService/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ImageService service

type ImageServiceServer interface {
	List(context.Context, *Reference) (*ImageList, error)
}

func RegisterImageServiceServer(s *grpc.Server, srv ImageServiceServer) {
	s.RegisterService(&_ImageService_serviceDesc, srv)
}

func _ImageService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Reference)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ImageService/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).List(ctx, req.(*Reference))
	}
	return interceptor(ctx, in, info, handler)
}

var _ImageService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ImageService",
	HandlerType: (*ImageServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _ImageService_List_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "brokerd.proto",
}

// Client API for NetworkService service

type NetworkServiceClient interface {
	Create(ctx context.Context, in *NetworkDefinition, opts ...grpc.CallOption) (*Network, error)
	List(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*NetworkList, error)
	Inspect(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*Network, error)
	Delete(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
}

type networkServiceClient struct {
	cc *grpc.ClientConn
}

func NewNetworkServiceClient(cc *grpc.ClientConn) NetworkServiceClient {
	return &networkServiceClient{cc}
}

func (c *networkServiceClient) Create(ctx context.Context, in *NetworkDefinition, opts ...grpc.CallOption) (*Network, error) {
	out := new(Network)
	err := grpc.Invoke(ctx, "/NetworkService/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkServiceClient) List(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*NetworkList, error) {
	out := new(NetworkList)
	err := grpc.Invoke(ctx, "/NetworkService/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkServiceClient) Inspect(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*Network, error) {
	out := new(Network)
	err := grpc.Invoke(ctx, "/NetworkService/Inspect", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkServiceClient) Delete(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/NetworkService/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for NetworkService service

type NetworkServiceServer interface {
	Create(context.Context, *NetworkDefinition) (*Network, error)
	List(context.Context, *google_protobuf.Empty) (*NetworkList, error)
	Inspect(context.Context, *Reference) (*Network, error)
	Delete(context.Context, *Reference) (*google_protobuf.Empty, error)
}

func RegisterNetworkServiceServer(s *grpc.Server, srv NetworkServiceServer) {
	s.RegisterService(&_NetworkService_serviceDesc, srv)
}

func _NetworkService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkDefinition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/NetworkService/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkServiceServer).Create(ctx, req.(*NetworkDefinition))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/NetworkService/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkServiceServer).List(ctx, req.(*google_protobuf.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkService_Inspect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Reference)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkServiceServer).Inspect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/NetworkService/Inspect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkServiceServer).Inspect(ctx, req.(*Reference))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Reference)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/NetworkService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkServiceServer).Delete(ctx, req.(*Reference))
	}
	return interceptor(ctx, in, info, handler)
}

var _NetworkService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "NetworkService",
	HandlerType: (*NetworkServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _NetworkService_Create_Handler,
		},
		{
			MethodName: "List",
			Handler:    _NetworkService_List_Handler,
		},
		{
			MethodName: "Inspect",
			Handler:    _NetworkService_Inspect_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _NetworkService_Delete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "brokerd.proto",
}

// Client API for VMService service

type VMServiceClient interface {
	Create(ctx context.Context, in *VMDefinition, opts ...grpc.CallOption) (*VM, error)
	Inspect(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*VM, error)
	List(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*VMList, error)
	Delete(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	SSH(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*SshConfig, error)
}

type vMServiceClient struct {
	cc *grpc.ClientConn
}

func NewVMServiceClient(cc *grpc.ClientConn) VMServiceClient {
	return &vMServiceClient{cc}
}

func (c *vMServiceClient) Create(ctx context.Context, in *VMDefinition, opts ...grpc.CallOption) (*VM, error) {
	out := new(VM)
	err := grpc.Invoke(ctx, "/VMService/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) Inspect(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*VM, error) {
	out := new(VM)
	err := grpc.Invoke(ctx, "/VMService/Inspect", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) List(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*VMList, error) {
	out := new(VMList)
	err := grpc.Invoke(ctx, "/VMService/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) Delete(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/VMService/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) SSH(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*SshConfig, error) {
	out := new(SshConfig)
	err := grpc.Invoke(ctx, "/VMService/SSH", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for VMService service

type VMServiceServer interface {
	Create(context.Context, *VMDefinition) (*VM, error)
	Inspect(context.Context, *Reference) (*VM, error)
	List(context.Context, *google_protobuf.Empty) (*VMList, error)
	Delete(context.Context, *Reference) (*google_protobuf.Empty, error)
	SSH(context.Context, *Reference) (*SshConfig, error)
}

func RegisterVMServiceServer(s *grpc.Server, srv VMServiceServer) {
	s.RegisterService(&_VMService_serviceDesc, srv)
}

func _VMService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMDefinition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/VMService/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).Create(ctx, req.(*VMDefinition))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_Inspect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Reference)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).Inspect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/VMService/Inspect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).Inspect(ctx, req.(*Reference))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/VMService/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).List(ctx, req.(*google_protobuf.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Reference)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/VMService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).Delete(ctx, req.(*Reference))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_SSH_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Reference)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).SSH(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/VMService/SSH",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).SSH(ctx, req.(*Reference))
	}
	return interceptor(ctx, in, info, handler)
}

var _VMService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "VMService",
	HandlerType: (*VMServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _VMService_Create_Handler,
		},
		{
			MethodName: "Inspect",
			Handler:    _VMService_Inspect_Handler,
		},
		{
			MethodName: "List",
			Handler:    _VMService_List_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _VMService_Delete_Handler,
		},
		{
			MethodName: "SSH",
			Handler:    _VMService_SSH_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "brokerd.proto",
}

// Client API for VolumeService service

type VolumeServiceClient interface {
	Create(ctx context.Context, in *VolumeDefinition, opts ...grpc.CallOption) (*Volume, error)
	Attach(ctx context.Context, in *VolumeAttachment, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	Detach(ctx context.Context, in *VolumeDetachment, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	Delete(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	List(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*VolumeList, error)
	Inspect(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*Volume, error)
}

type volumeServiceClient struct {
	cc *grpc.ClientConn
}

func NewVolumeServiceClient(cc *grpc.ClientConn) VolumeServiceClient {
	return &volumeServiceClient{cc}
}

func (c *volumeServiceClient) Create(ctx context.Context, in *VolumeDefinition, opts ...grpc.CallOption) (*Volume, error) {
	out := new(Volume)
	err := grpc.Invoke(ctx, "/VolumeService/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeServiceClient) Attach(ctx context.Context, in *VolumeAttachment, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/VolumeService/Attach", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeServiceClient) Detach(ctx context.Context, in *VolumeDetachment, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/VolumeService/Detach", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeServiceClient) Delete(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/VolumeService/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeServiceClient) List(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*VolumeList, error) {
	out := new(VolumeList)
	err := grpc.Invoke(ctx, "/VolumeService/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeServiceClient) Inspect(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*Volume, error) {
	out := new(Volume)
	err := grpc.Invoke(ctx, "/VolumeService/Inspect", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for VolumeService service

type VolumeServiceServer interface {
	Create(context.Context, *VolumeDefinition) (*Volume, error)
	Attach(context.Context, *VolumeAttachment) (*google_protobuf.Empty, error)
	Detach(context.Context, *VolumeDetachment) (*google_protobuf.Empty, error)
	Delete(context.Context, *Reference) (*google_protobuf.Empty, error)
	List(context.Context, *google_protobuf.Empty) (*VolumeList, error)
	Inspect(context.Context, *Reference) (*Volume, error)
}

func RegisterVolumeServiceServer(s *grpc.Server, srv VolumeServiceServer) {
	s.RegisterService(&_VolumeService_serviceDesc, srv)
}

func _VolumeService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VolumeDefinition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/VolumeService/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServiceServer).Create(ctx, req.(*VolumeDefinition))
	}
	return interceptor(ctx, in, info, handler)
}

func _VolumeService_Attach_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VolumeAttachment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServiceServer).Attach(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/VolumeService/Attach",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServiceServer).Attach(ctx, req.(*VolumeAttachment))
	}
	return interceptor(ctx, in, info, handler)
}

func _VolumeService_Detach_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VolumeDetachment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServiceServer).Detach(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/VolumeService/Detach",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServiceServer).Detach(ctx, req.(*VolumeDetachment))
	}
	return interceptor(ctx, in, info, handler)
}

func _VolumeService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Reference)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/VolumeService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServiceServer).Delete(ctx, req.(*Reference))
	}
	return interceptor(ctx, in, info, handler)
}

func _VolumeService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/VolumeService/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServiceServer).List(ctx, req.(*google_protobuf.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VolumeService_Inspect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Reference)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServiceServer).Inspect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/VolumeService/Inspect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServiceServer).Inspect(ctx, req.(*Reference))
	}
	return interceptor(ctx, in, info, handler)
}

var _VolumeService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "VolumeService",
	HandlerType: (*VolumeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _VolumeService_Create_Handler,
		},
		{
			MethodName: "Attach",
			Handler:    _VolumeService_Attach_Handler,
		},
		{
			MethodName: "Detach",
			Handler:    _VolumeService_Detach_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _VolumeService_Delete_Handler,
		},
		{
			MethodName: "List",
			Handler:    _VolumeService_List_Handler,
		},
		{
			MethodName: "Inspect",
			Handler:    _VolumeService_Inspect_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "brokerd.proto",
}

// Client API for ContainerService service

type ContainerServiceClient interface {
	Create(ctx context.Context, in *Container, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	Mount(ctx context.Context, in *ContainerMountingPoint, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	UMount(ctx context.Context, in *ContainerMountingPoint, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	Delete(ctx context.Context, in *Container, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	List(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*ContainerList, error)
	Inspect(ctx context.Context, in *Container, opts ...grpc.CallOption) (*ContainerMountingPoint, error)
}

type containerServiceClient struct {
	cc *grpc.ClientConn
}

func NewContainerServiceClient(cc *grpc.ClientConn) ContainerServiceClient {
	return &containerServiceClient{cc}
}

func (c *containerServiceClient) Create(ctx context.Context, in *Container, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/ContainerService/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *containerServiceClient) Mount(ctx context.Context, in *ContainerMountingPoint, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/ContainerService/Mount", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *containerServiceClient) UMount(ctx context.Context, in *ContainerMountingPoint, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/ContainerService/UMount", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *containerServiceClient) Delete(ctx context.Context, in *Container, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/ContainerService/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *containerServiceClient) List(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*ContainerList, error) {
	out := new(ContainerList)
	err := grpc.Invoke(ctx, "/ContainerService/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *containerServiceClient) Inspect(ctx context.Context, in *Container, opts ...grpc.CallOption) (*ContainerMountingPoint, error) {
	out := new(ContainerMountingPoint)
	err := grpc.Invoke(ctx, "/ContainerService/Inspect", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ContainerService service

type ContainerServiceServer interface {
	Create(context.Context, *Container) (*google_protobuf.Empty, error)
	Mount(context.Context, *ContainerMountingPoint) (*google_protobuf.Empty, error)
	UMount(context.Context, *ContainerMountingPoint) (*google_protobuf.Empty, error)
	Delete(context.Context, *Container) (*google_protobuf.Empty, error)
	List(context.Context, *google_protobuf.Empty) (*ContainerList, error)
	Inspect(context.Context, *Container) (*ContainerMountingPoint, error)
}

func RegisterContainerServiceServer(s *grpc.Server, srv ContainerServiceServer) {
	s.RegisterService(&_ContainerService_serviceDesc, srv)
}

func _ContainerService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Container)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContainerServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ContainerService/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContainerServiceServer).Create(ctx, req.(*Container))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContainerService_Mount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContainerMountingPoint)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContainerServiceServer).Mount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ContainerService/Mount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContainerServiceServer).Mount(ctx, req.(*ContainerMountingPoint))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContainerService_UMount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContainerMountingPoint)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContainerServiceServer).UMount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ContainerService/UMount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContainerServiceServer).UMount(ctx, req.(*ContainerMountingPoint))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContainerService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Container)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContainerServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ContainerService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContainerServiceServer).Delete(ctx, req.(*Container))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContainerService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContainerServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ContainerService/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContainerServiceServer).List(ctx, req.(*google_protobuf.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContainerService_Inspect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Container)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContainerServiceServer).Inspect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ContainerService/Inspect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContainerServiceServer).Inspect(ctx, req.(*Container))
	}
	return interceptor(ctx, in, info, handler)
}

var _ContainerService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ContainerService",
	HandlerType: (*ContainerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _ContainerService_Create_Handler,
		},
		{
			MethodName: "Mount",
			Handler:    _ContainerService_Mount_Handler,
		},
		{
			MethodName: "UMount",
			Handler:    _ContainerService_UMount_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _ContainerService_Delete_Handler,
		},
		{
			MethodName: "List",
			Handler:    _ContainerService_List_Handler,
		},
		{
			MethodName: "Inspect",
			Handler:    _ContainerService_Inspect_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "brokerd.proto",
}

// Client API for SshService service

type SshServiceClient interface {
	Run(ctx context.Context, in *SshCommand, opts ...grpc.CallOption) (*SshResponse, error)
	Copy(ctx context.Context, in *SshCopyCommand, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
}

type sshServiceClient struct {
	cc *grpc.ClientConn
}

func NewSshServiceClient(cc *grpc.ClientConn) SshServiceClient {
	return &sshServiceClient{cc}
}

func (c *sshServiceClient) Run(ctx context.Context, in *SshCommand, opts ...grpc.CallOption) (*SshResponse, error) {
	out := new(SshResponse)
	err := grpc.Invoke(ctx, "/SshService/Run", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sshServiceClient) Copy(ctx context.Context, in *SshCopyCommand, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/SshService/Copy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SshService service

type SshServiceServer interface {
	Run(context.Context, *SshCommand) (*SshResponse, error)
	Copy(context.Context, *SshCopyCommand) (*google_protobuf.Empty, error)
}

func RegisterSshServiceServer(s *grpc.Server, srv SshServiceServer) {
	s.RegisterService(&_SshService_serviceDesc, srv)
}

func _SshService_Run_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SshCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SshServiceServer).Run(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/SshService/Run",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SshServiceServer).Run(ctx, req.(*SshCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _SshService_Copy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SshCopyCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SshServiceServer).Copy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/SshService/Copy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SshServiceServer).Copy(ctx, req.(*SshCopyCommand))
	}
	return interceptor(ctx, in, info, handler)
}

var _SshService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "SshService",
	HandlerType: (*SshServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Run",
			Handler:    _SshService_Run_Handler,
		},
		{
			MethodName: "Copy",
			Handler:    _SshService_Copy_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "brokerd.proto",
}

func init() { proto.RegisterFile("brokerd.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1359 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0xcf, 0x6e, 0xdb, 0x46,
	0x13, 0x17, 0x45, 0x89, 0x14, 0x47, 0xb6, 0x3f, 0x65, 0x81, 0xcf, 0x9f, 0x20, 0x04, 0x8e, 0xbe,
	0x45, 0x51, 0x38, 0x7f, 0xba, 0x4e, 0x15, 0x04, 0x28, 0x92, 0x93, 0x2b, 0xba, 0x89, 0x92, 0xc8,
	0x26, 0x56, 0xb6, 0x8e, 0x05, 0x68, 0x69, 0x2d, 0x11, 0xb6, 0x48, 0x82, 0x5c, 0x39, 0x70, 0x9e,
	0xa0, 0x97, 0xbe, 0x46, 0x1f, 0xa0, 0xf7, 0x1e, 0x7b, 0x6d, 0x6f, 0x7d, 0x9e, 0x62, 0x97, 0xbb,
	0xa4, 0x14, 0xc9, 0x96, 0x93, 0x8b, 0xad, 0x99, 0xd9, 0x99, 0xfd, 0xcd, 0x6f, 0x66, 0x67, 0x08,
	0xdb, 0xe7, 0x49, 0x74, 0xc9, 0x92, 0x31, 0x89, 0x93, 0x88, 0x47, 0xad, 0x17, 0x93, 0x80, 0x4f,
	0xe7, 0xe7, 0x64, 0x14, 0xcd, 0x0e, 0x26, 0xd1, 0x95, 0x1f, 0x4e, 0x0e, 0xa4, 0xe1, 0x7c, 0x7e,
	0x71, 0x10, 0xf3, 0x9b, 0x98, 0xa5, 0x07, 0x6c, 0x16, 0xf3, 0x9b, 0xec, 0x6f, 0xe6, 0x84, 0x7f,
	0x00, 0xeb, 0x94, 0x85, 0x7e, 0xc8, 0x11, 0x82, 0xca, 0xb1, 0x3f, 0x63, 0x4d, 0xa3, 0x6d, 0xec,
	0x3b, 0xb4, 0x12, 0xfa, 0x33, 0x86, 0x5a, 0x50, 0xf3, 0x92, 0xe8, 0x3a, 0x18, 0xb3, 0xa4, 0x59,
	0x96, 0xfa, 0x5a, 0xac, 0x64, 0x7c, 0x00, 0x90, 0x79, 0x7e, 0x08, 0x52, 0x8e, 0xfe, 0x0f, 0x76,
	0x26, 0xa5, 0x4d, 0xa3, 0x6d, 0xee, 0xd7, 0x3b, 0x36, 0xc9, 0x64, 0x6a, 0xf3, 0x4c, 0x8f, 0x9f,
	0x42, 0xb5, 0x37, 0xf3, 0x27, 0x0c, 0xed, 0x40, 0xb9, 0xe7, 0xaa, 0x7b, 0xca, 0x81, 0x9b, 0xdf,
	0x5c, 0x2e, 0x6e, 0xc6, 0xef, 0xc1, 0xa1, 0xec, 0x82, 0x25, 0x2c, 0x1c, 0x49, 0x18, 0x59, 0xb0,
	0xdc, 0xad, 0xc6, 0x95, 0xac, 0x82, 0x95, 0x57, 0x82, 0x99, 0x0b, 0xc1, 0xda, 0x1a, 0xaa, 0xb0,
	0xac, 0x4b, 0x14, 0x3f, 0x05, 0x47, 0x62, 0x93, 0xb9, 0xec, 0x81, 0x25, 0x05, 0x9d, 0x8a, 0x45,
	0xa4, 0x48, 0xad, 0x40, 0x6a, 0x71, 0x00, 0x0f, 0x8e, 0x19, 0xff, 0x18, 0x25, 0x97, 0x2e, 0xbb,
	0x08, 0xc2, 0x80, 0x07, 0x51, 0xb8, 0x2e, 0x09, 0xa1, 0xeb, 0xf6, 0x5c, 0xaa, 0xb1, 0x8c, 0x7a,
	0x2e, 0x45, 0xcf, 0xc0, 0x7e, 0xe3, 0x73, 0xf6, 0xd1, 0xbf, 0x69, 0x56, 0xda, 0xc6, 0x7e, 0xbd,
	0x83, 0x88, 0x92, 0x8b, 0x60, 0xd4, 0x9e, 0x64, 0x2a, 0xcc, 0xe0, 0xc1, 0x8a, 0x15, 0x35, 0xc0,
	0xec, 0x7a, 0x67, 0x12, 0x7f, 0x95, 0x9a, 0x23, 0xef, 0x4c, 0x68, 0xe8, 0x61, 0x5f, 0xde, 0x5d,
	0xa6, 0x66, 0x72, 0xd8, 0x17, 0x57, 0xbb, 0x41, 0x7a, 0x29, 0xaf, 0xae, 0xd2, 0xca, 0x38, 0x48,
	0x2f, 0x51, 0x13, 0x6c, 0x99, 0x48, 0xcf, 0x6d, 0x56, 0x25, 0x22, 0x3b, 0xc8, 0x44, 0x7c, 0x08,
	0xb6, 0xca, 0xe8, 0x3e, 0xc5, 0x59, 0x97, 0x17, 0x7e, 0x01, 0x75, 0x15, 0x42, 0x72, 0xf8, 0x0d,
	0xd4, 0x94, 0xa8, 0x59, 0xac, 0x11, 0xa5, 0xa0, 0xb5, 0x50, 0x59, 0xf0, 0xef, 0x06, 0x6c, 0x0d,
	0xfb, 0x1b, 0x58, 0x6c, 0xe6, 0xe0, 0xd4, 0x85, 0xb6, 0xf2, 0x47, 0x0f, 0xc1, 0xe9, 0x7a, 0x67,
	0xc7, 0xf3, 0xd9, 0x39, 0x4b, 0x24, 0x9b, 0x55, 0xea, 0x8c, 0xb4, 0x42, 0x93, 0x62, 0xad, 0x92,
	0x62, 0xaf, 0x27, 0xc5, 0x59, 0x22, 0x05, 0xed, 0x82, 0xe5, 0xcd, 0xcf, 0xaf, 0x82, 0x51, 0x13,
	0xda, 0xc6, 0x7e, 0x8d, 0x5a, 0xb1, 0x94, 0xf0, 0x5f, 0x06, 0x94, 0x87, 0xfd, 0x7b, 0x11, 0xa5,
	0x2a, 0x65, 0xae, 0x54, 0xaa, 0xb2, 0x0a, 0xaa, 0xba, 0x00, 0x4a, 0xc4, 0xf6, 0x24, 0x72, 0x11,
	0xdb, 0x43, 0x7b, 0x50, 0x1d, 0x70, 0x9f, 0xb3, 0x66, 0xad, 0x6d, 0xec, 0xef, 0x74, 0x6a, 0x64,
	0xd8, 0x97, 0x32, 0xad, 0xa6, 0xe2, 0x1f, 0xda, 0x03, 0xf0, 0x92, 0xe0, 0xda, 0xe7, 0xec, 0x3d,
	0xbb, 0x51, 0x79, 0x40, 0x9c, 0x6b, 0x04, 0x51, 0xaa, 0x8d, 0x7a, 0xae, 0xcc, 0xc6, 0xa1, 0xce,
	0x44, 0x2b, 0xf0, 0x23, 0xb0, 0x86, 0x7d, 0x59, 0xb5, 0xff, 0x82, 0x39, 0xec, 0xeb, 0x82, 0x99,
	0x64, 0xd8, 0xa7, 0xe6, 0x75, 0x3f, 0xc5, 0xbf, 0x1a, 0xe0, 0x0c, 0xd2, 0x69, 0x37, 0x0a, 0x2f,
	0x82, 0x89, 0x00, 0x7c, 0x96, 0xb2, 0x44, 0xbf, 0x9f, 0x79, 0xca, 0x12, 0xa1, 0x7b, 0x1b, 0xa5,
	0x5c, 0x27, 0x3f, 0x8d, 0xe4, 0x33, 0x5a, 0x04, 0x65, 0xae, 0x80, 0x42, 0x50, 0xf1, 0xa2, 0x84,
	0xab, 0xc2, 0x55, 0xe2, 0x28, 0x11, 0x6d, 0xa3, 0x5b, 0x5f, 0xf2, 0x51, 0xef, 0x00, 0xc9, 0x2f,
	0x2e, 0x5e, 0xc5, 0xcf, 0xd0, 0x18, 0x46, 0x57, 0xf3, 0x19, 0xdb, 0xd0, 0x39, 0x18, 0xaa, 0x83,
	0x98, 0xb1, 0xb1, 0xbc, 0x7c, 0xa7, 0xb3, 0x45, 0x32, 0x2f, 0xa9, 0xa3, 0xd5, 0x54, 0xfc, 0x13,
	0x7e, 0x83, 0xe0, 0x13, 0xd3, 0x28, 0xd2, 0xe0, 0x13, 0xc3, 0x63, 0xb0, 0xb2, 0x93, 0xf7, 0x2a,
	0xf2, 0xd7, 0xde, 0x72, 0x00, 0x90, 0x9d, 0xd4, 0x03, 0xf4, 0x5a, 0x4a, 0xc5, 0x00, 0xcd, 0xac,
	0x54, 0xeb, 0xf1, 0x2f, 0x86, 0xce, 0xfb, 0x90, 0x73, 0x7f, 0x34, 0x9d, 0xb1, 0x90, 0x23, 0xac,
	0xb1, 0x4a, 0x4c, 0x82, 0xb0, 0x7c, 0x6e, 0x52, 0x2b, 0xf3, 0x44, 0x2d, 0xd1, 0xb0, 0x12, 0xde,
	0xb2, 0xbd, 0x7c, 0xdd, 0x17, 0xad, 0xd1, 0x8f, 0xe6, 0x21, 0xf7, 0x7c, 0x3e, 0x95, 0xf0, 0x1c,
	0xea, 0xcc, 0xb4, 0x42, 0xbc, 0x81, 0x9f, 0xa2, 0x64, 0xe6, 0x73, 0x35, 0x31, 0xac, 0x0b, 0x29,
	0x61, 0x5a, 0x54, 0x60, 0x0d, 0x12, 0x63, 0x03, 0x92, 0xf2, 0x3a, 0x24, 0xf8, 0x11, 0x38, 0xdd,
	0x28, 0xe4, 0x7e, 0x10, 0x66, 0x0d, 0xb5, 0xb2, 0x13, 0x5e, 0xc3, 0x76, 0x7e, 0x40, 0x72, 0xf6,
	0x04, 0x20, 0x57, 0x68, 0xda, 0x80, 0xe4, 0x2a, 0x0a, 0xa3, 0xdc, 0x8a, 0x2f, 0x60, 0x37, 0x37,
	0xc8, 0x84, 0x83, 0x70, 0xe2, 0x45, 0x41, 0xc8, 0xe5, 0x14, 0xd1, 0x16, 0x55, 0x6a, 0x27, 0x77,
	0xbc, 0x0b, 0xb1, 0xec, 0x60, 0x41, 0x9b, 0x9a, 0x83, 0xb1, 0xcf, 0xa7, 0xf8, 0x47, 0x00, 0xd9,
	0xb1, 0xb3, 0x99, 0x1f, 0x8e, 0x95, 0xb7, 0xb1, 0xd6, 0xbb, 0x09, 0xb6, 0x3a, 0xa6, 0xb2, 0xb4,
	0x47, 0x99, 0x88, 0xdf, 0xc1, 0x8e, 0x8c, 0x11, 0xdf, 0xe8, 0x38, 0xbb, 0x60, 0x0d, 0xa2, 0x79,
	0x32, 0xd2, 0x5b, 0xcb, 0x4a, 0xa5, 0x84, 0xda, 0x50, 0x77, 0x59, 0xca, 0x83, 0xd0, 0x17, 0x8f,
	0x40, 0xc5, 0xa9, 0x8f, 0x0b, 0x15, 0x3e, 0x81, 0xfa, 0x20, 0x9d, 0x52, 0x96, 0xc6, 0x51, 0x98,
	0x32, 0x11, 0x28, 0x9a, 0xf3, 0x78, 0xce, 0x75, 0xa0, 0x4c, 0x12, 0x73, 0x89, 0x25, 0x7a, 0xc9,
	0x8b, 0x9f, 0xe2, 0xa4, 0x18, 0x2e, 0xf3, 0x54, 0x8d, 0x2f, 0x25, 0x3d, 0x79, 0x07, 0xb6, 0x9a,
	0x3e, 0xa8, 0x0e, 0xf6, 0xe0, 0xf4, 0xc4, 0xf3, 0x8e, 0xdc, 0x46, 0x09, 0x6d, 0x41, 0x6d, 0x70,
	0x7a, 0x48, 0x4f, 0x7b, 0xc7, 0x6f, 0x1a, 0x46, 0x66, 0x3a, 0xa4, 0xa7, 0x47, 0x6e, 0xa3, 0x9c,
	0x99, 0x4e, 0x3c, 0x4f, 0x98, 0x4c, 0xe4, 0x40, 0xf5, 0x88, 0xd2, 0x13, 0xda, 0xa8, 0x3c, 0x79,
	0x0c, 0xf5, 0x85, 0xc7, 0x82, 0x6a, 0x50, 0xe9, 0x9e, 0x7c, 0x10, 0xc1, 0x6c, 0x30, 0xdf, 0xba,
	0x6e, 0xc3, 0x10, 0x3f, 0x06, 0x03, 0xb7, 0x51, 0xee, 0xfc, 0x63, 0xc0, 0x76, 0xb6, 0xc4, 0x07,
	0x2c, 0xb9, 0x0e, 0x46, 0x0c, 0x7d, 0x07, 0x15, 0xd9, 0x05, 0xbb, 0x64, 0x12, 0x45, 0x93, 0x2b,
	0x46, 0xf4, 0xd7, 0x0e, 0x39, 0x12, 0x1f, 0x38, 0xad, 0x3a, 0x29, 0xbe, 0x4f, 0x70, 0x09, 0xbd,
	0x02, 0x8b, 0xb2, 0xab, 0xc8, 0x1f, 0xdf, 0xea, 0x70, 0x8b, 0x1e, 0x97, 0xd0, 0x33, 0x30, 0x07,
	0x8c, 0x23, 0x1d, 0x51, 0x74, 0xe6, 0xdd, 0xa7, 0xdf, 0xb0, 0xcd, 0xb8, 0x44, 0x14, 0x5c, 0xea,
	0x3c, 0x87, 0x2d, 0xb9, 0x80, 0x74, 0x5a, 0x6d, 0x95, 0xd6, 0x42, 0xbb, 0xb4, 0x80, 0xe4, 0x5f,
	0x27, 0xb8, 0xd4, 0xf9, 0xc3, 0x80, 0x1d, 0xb5, 0x11, 0xb5, 0xd3, 0x3e, 0x58, 0xdd, 0x84, 0x89,
	0x9a, 0x20, 0xb2, 0xf2, 0x6d, 0xd2, 0xca, 0x57, 0x2f, 0x2e, 0x21, 0xb2, 0x81, 0xb5, 0x2d, 0xb2,
	0xb0, 0xc6, 0x71, 0x49, 0xcc, 0xa5, 0x5e, 0x98, 0xc6, 0x6c, 0xb4, 0x8c, 0x68, 0x39, 0xa4, 0xe5,
	0xb2, 0x2b, 0xc6, 0xd9, 0xd2, 0x89, 0x5b, 0xf9, 0xe9, 0xfc, 0x69, 0x80, 0x33, 0xec, 0x6b, 0xe8,
	0x7b, 0x39, 0xf4, 0x6d, 0xb2, 0xf8, 0x2d, 0xd0, 0x12, 0xfb, 0x07, 0x97, 0xd0, 0xc3, 0xf5, 0x00,
	0x94, 0xf5, 0xf1, 0x86, 0x74, 0x6c, 0x92, 0xad, 0xb6, 0x2f, 0x87, 0x89, 0x1e, 0x89, 0xd6, 0x7b,
	0xfb, 0x59, 0x1d, 0xf2, 0x6d, 0x84, 0x4b, 0x9d, 0xdf, 0xca, 0xb0, 0xad, 0xda, 0x57, 0xe5, 0xf2,
	0x6d, 0x9e, 0xcb, 0x03, 0xf2, 0xf9, 0x86, 0x6a, 0xe9, 0x81, 0x8e, 0x4b, 0xe8, 0x25, 0x58, 0xd9,
	0x08, 0xcf, 0xcf, 0x15, 0x13, 0xfd, 0x0e, 0x44, 0x2f, 0x45, 0x06, 0x4b, 0x6e, 0xc5, 0xf8, 0xbd,
	0xc3, 0xed, 0x4b, 0x13, 0xdf, 0xfc, 0xb0, 0x8a, 0xbd, 0x85, 0x4b, 0xa8, 0xbd, 0xbe, 0x40, 0x45,
	0xba, 0x9d, 0xbf, 0xcb, 0xd0, 0xc8, 0x47, 0xac, 0xe6, 0x8a, 0xe4, 0x5c, 0x2d, 0x8c, 0xec, 0x3b,
	0x50, 0xbd, 0x82, 0xaa, 0x9c, 0xdb, 0xe8, 0x7f, 0x64, 0xfd, 0x20, 0xbf, 0xc3, 0xf7, 0x35, 0x58,
	0x67, 0x5f, 0xed, 0xbc, 0x48, 0xdf, 0x7d, 0x80, 0x3e, 0xdf, 0x40, 0xdf, 0x0e, 0x59, 0xda, 0x62,
	0xd2, 0x63, 0x81, 0xc1, 0xe2, 0x8a, 0xdb, 0xb0, 0xe2, 0x52, 0x67, 0x24, 0xb7, 0x8c, 0xa6, 0x12,
	0x83, 0x49, 0xe7, 0x21, 0xaa, 0x93, 0x62, 0xf3, 0xb4, 0xb6, 0xc8, 0xc2, 0xd8, 0xc7, 0x25, 0xf4,
	0x3d, 0x54, 0xc4, 0x42, 0x41, 0xff, 0x21, 0xcb, 0xab, 0xe5, 0xf6, 0x44, 0xce, 0x2d, 0xa9, 0x79,
	0xf1, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xe2, 0x29, 0x5a, 0x6e, 0x68, 0x0e, 0x00, 0x00,
}
