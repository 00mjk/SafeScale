// Code generated by protoc-gen-go. DO NOT EDIT.
// source: brokerd.proto

/*
Package brokerd is a generated protocol buffer package.

It is generated from these files:
	brokerd.proto

It has these top-level messages:
	Empty
	Tenant
	TenantList
	Image
	Reference
	TenantName
	ImageList
	NetworkDefinition
	GatewayDefinition
	Network
	NetworkList
	VMDefinition
	VM
	VMList
	SshConfig
	VolumeDefinition
	Volume
	VolumeList
	VolumeAttachment
	VolumeDetachment
	Container
	ContainerMountingPoint
*/
package brokerd

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type VMState int32

const (
	// STOPPED VM is stopped
	VMState_STOPPED VMState = 0
	// STARTING VM is starting
	VMState_STARTING VMState = 1
	// STARTED VM is started
	VMState_STARTED VMState = 2
	// STOPPING VM is stopping
	VMState_STOPPING VMState = 3
	// ERROR VM is in error state
	VMState_ERROR VMState = 4
)

var VMState_name = map[int32]string{
	0: "STOPPED",
	1: "STARTING",
	2: "STARTED",
	3: "STOPPING",
	4: "ERROR",
}
var VMState_value = map[string]int32{
	"STOPPED":  0,
	"STARTING": 1,
	"STARTED":  2,
	"STOPPING": 3,
	"ERROR":    4,
}

func (x VMState) String() string {
	return proto.EnumName(VMState_name, int32(x))
}
func (VMState) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type VolumeSpeed int32

const (
	VolumeSpeed_COLD VolumeSpeed = 0
	VolumeSpeed_HDD  VolumeSpeed = 1
	VolumeSpeed_SSD  VolumeSpeed = 2
)

var VolumeSpeed_name = map[int32]string{
	0: "COLD",
	1: "HDD",
	2: "SSD",
}
var VolumeSpeed_value = map[string]int32{
	"COLD": 0,
	"HDD":  1,
	"SSD":  2,
}

func (x VolumeSpeed) String() string {
	return proto.EnumName(VolumeSpeed_name, int32(x))
}
func (VolumeSpeed) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Tenant struct {
	Name     string `protobuf:"bytes,1,opt,name=Name,json=name" json:"Name,omitempty"`
	Provider string `protobuf:"bytes,2,opt,name=Provider,json=provider" json:"Provider,omitempty"`
}

func (m *Tenant) Reset()                    { *m = Tenant{} }
func (m *Tenant) String() string            { return proto.CompactTextString(m) }
func (*Tenant) ProtoMessage()               {}
func (*Tenant) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Tenant) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Tenant) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

type TenantList struct {
	Tenants []*Tenant `protobuf:"bytes,1,rep,name=Tenants,json=tenants" json:"Tenants,omitempty"`
}

func (m *TenantList) Reset()                    { *m = TenantList{} }
func (m *TenantList) String() string            { return proto.CompactTextString(m) }
func (*TenantList) ProtoMessage()               {}
func (*TenantList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *TenantList) GetTenants() []*Tenant {
	if m != nil {
		return m.Tenants
	}
	return nil
}

type Image struct {
	ID   string `protobuf:"bytes,1,opt,name=ID,json=iD" json:"ID,omitempty"`
	Name string `protobuf:"bytes,2,opt,name=Name,json=name" json:"Name,omitempty"`
}

func (m *Image) Reset()                    { *m = Image{} }
func (m *Image) String() string            { return proto.CompactTextString(m) }
func (*Image) ProtoMessage()               {}
func (*Image) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Image) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Image) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Reference struct {
	TenantID string `protobuf:"bytes,1,opt,name=TenantID,json=tenantID" json:"TenantID,omitempty"`
	ID       string `protobuf:"bytes,2,opt,name=ID,json=iD" json:"ID,omitempty"`
	Name     string `protobuf:"bytes,3,opt,name=Name,json=name" json:"Name,omitempty"`
}

func (m *Reference) Reset()                    { *m = Reference{} }
func (m *Reference) String() string            { return proto.CompactTextString(m) }
func (*Reference) ProtoMessage()               {}
func (*Reference) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Reference) GetTenantID() string {
	if m != nil {
		return m.TenantID
	}
	return ""
}

func (m *Reference) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Reference) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type TenantName struct {
	Name string `protobuf:"bytes,1,opt,name=Name,json=name" json:"Name,omitempty"`
}

func (m *TenantName) Reset()                    { *m = TenantName{} }
func (m *TenantName) String() string            { return proto.CompactTextString(m) }
func (*TenantName) ProtoMessage()               {}
func (*TenantName) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *TenantName) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type ImageList struct {
	Images []*Image `protobuf:"bytes,1,rep,name=Images,json=images" json:"Images,omitempty"`
}

func (m *ImageList) Reset()                    { *m = ImageList{} }
func (m *ImageList) String() string            { return proto.CompactTextString(m) }
func (*ImageList) ProtoMessage()               {}
func (*ImageList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ImageList) GetImages() []*Image {
	if m != nil {
		return m.Images
	}
	return nil
}

type NetworkDefinition struct {
	Tenant  string             `protobuf:"bytes,1,opt,name=Tenant,json=tenant" json:"Tenant,omitempty"`
	Name    string             `protobuf:"bytes,2,opt,name=Name,json=name" json:"Name,omitempty"`
	CIDR    string             `protobuf:"bytes,3,opt,name=CIDR,json=cIDR" json:"CIDR,omitempty"`
	Gateway *GatewayDefinition `protobuf:"bytes,4,opt,name=Gateway,json=gateway" json:"Gateway,omitempty"`
}

func (m *NetworkDefinition) Reset()                    { *m = NetworkDefinition{} }
func (m *NetworkDefinition) String() string            { return proto.CompactTextString(m) }
func (*NetworkDefinition) ProtoMessage()               {}
func (*NetworkDefinition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *NetworkDefinition) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

func (m *NetworkDefinition) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NetworkDefinition) GetCIDR() string {
	if m != nil {
		return m.CIDR
	}
	return ""
}

func (m *NetworkDefinition) GetGateway() *GatewayDefinition {
	if m != nil {
		return m.Gateway
	}
	return nil
}

type GatewayDefinition struct {
	CPU          int32   `protobuf:"varint,1,opt,name=CPU,json=cPU" json:"CPU,omitempty"`
	RAM          float32 `protobuf:"fixed32,2,opt,name=RAM,json=rAM" json:"RAM,omitempty"`
	Disk         int32   `protobuf:"varint,3,opt,name=Disk,json=disk" json:"Disk,omitempty"`
	CPUFrequency float32 `protobuf:"fixed32,4,opt,name=CPUFrequency,json=cPUFrequency" json:"CPUFrequency,omitempty"`
	ImageID      string  `protobuf:"bytes,5,opt,name=ImageID,json=imageID" json:"ImageID,omitempty"`
}

func (m *GatewayDefinition) Reset()                    { *m = GatewayDefinition{} }
func (m *GatewayDefinition) String() string            { return proto.CompactTextString(m) }
func (*GatewayDefinition) ProtoMessage()               {}
func (*GatewayDefinition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *GatewayDefinition) GetCPU() int32 {
	if m != nil {
		return m.CPU
	}
	return 0
}

func (m *GatewayDefinition) GetRAM() float32 {
	if m != nil {
		return m.RAM
	}
	return 0
}

func (m *GatewayDefinition) GetDisk() int32 {
	if m != nil {
		return m.Disk
	}
	return 0
}

func (m *GatewayDefinition) GetCPUFrequency() float32 {
	if m != nil {
		return m.CPUFrequency
	}
	return 0
}

func (m *GatewayDefinition) GetImageID() string {
	if m != nil {
		return m.ImageID
	}
	return ""
}

type Network struct {
	ID   string `protobuf:"bytes,1,opt,name=ID,json=iD" json:"ID,omitempty"`
	Name string `protobuf:"bytes,2,opt,name=Name,json=name" json:"Name,omitempty"`
	CIDR string `protobuf:"bytes,3,opt,name=CIDR,json=cIDR" json:"CIDR,omitempty"`
}

func (m *Network) Reset()                    { *m = Network{} }
func (m *Network) String() string            { return proto.CompactTextString(m) }
func (*Network) ProtoMessage()               {}
func (*Network) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *Network) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Network) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Network) GetCIDR() string {
	if m != nil {
		return m.CIDR
	}
	return ""
}

type NetworkList struct {
	Networks []*Network `protobuf:"bytes,1,rep,name=Networks,json=networks" json:"Networks,omitempty"`
}

func (m *NetworkList) Reset()                    { *m = NetworkList{} }
func (m *NetworkList) String() string            { return proto.CompactTextString(m) }
func (*NetworkList) ProtoMessage()               {}
func (*NetworkList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *NetworkList) GetNetworks() []*Network {
	if m != nil {
		return m.Networks
	}
	return nil
}

type VMDefinition struct {
	Tenant       string  `protobuf:"bytes,1,opt,name=Tenant,json=tenant" json:"Tenant,omitempty"`
	Name         string  `protobuf:"bytes,2,opt,name=Name,json=name" json:"Name,omitempty"`
	Network      string  `protobuf:"bytes,3,opt,name=Network,json=network" json:"Network,omitempty"`
	CPUNumber    int32   `protobuf:"varint,4,opt,name=CPUNumber,json=cPUNumber" json:"CPUNumber,omitempty"`
	CPUFrequency float32 `protobuf:"fixed32,5,opt,name=CPUFrequency,json=cPUFrequency" json:"CPUFrequency,omitempty"`
	RAM          float32 `protobuf:"fixed32,6,opt,name=RAM,json=rAM" json:"RAM,omitempty"`
	Disk         float32 `protobuf:"fixed32,7,opt,name=Disk,json=disk" json:"Disk,omitempty"`
	GPU          bool    `protobuf:"varint,8,opt,name=GPU,json=gPU" json:"GPU,omitempty"`
	ImageID      string  `protobuf:"bytes,9,opt,name=ImageID,json=imageID" json:"ImageID,omitempty"`
	Public       bool    `protobuf:"varint,10,opt,name=Public,json=public" json:"Public,omitempty"`
}

func (m *VMDefinition) Reset()                    { *m = VMDefinition{} }
func (m *VMDefinition) String() string            { return proto.CompactTextString(m) }
func (*VMDefinition) ProtoMessage()               {}
func (*VMDefinition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *VMDefinition) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

func (m *VMDefinition) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *VMDefinition) GetNetwork() string {
	if m != nil {
		return m.Network
	}
	return ""
}

func (m *VMDefinition) GetCPUNumber() int32 {
	if m != nil {
		return m.CPUNumber
	}
	return 0
}

func (m *VMDefinition) GetCPUFrequency() float32 {
	if m != nil {
		return m.CPUFrequency
	}
	return 0
}

func (m *VMDefinition) GetRAM() float32 {
	if m != nil {
		return m.RAM
	}
	return 0
}

func (m *VMDefinition) GetDisk() float32 {
	if m != nil {
		return m.Disk
	}
	return 0
}

func (m *VMDefinition) GetGPU() bool {
	if m != nil {
		return m.GPU
	}
	return false
}

func (m *VMDefinition) GetImageID() string {
	if m != nil {
		return m.ImageID
	}
	return ""
}

func (m *VMDefinition) GetPublic() bool {
	if m != nil {
		return m.Public
	}
	return false
}

type VM struct {
	ID         string  `protobuf:"bytes,1,opt,name=ID,json=iD" json:"ID,omitempty"`
	Name       string  `protobuf:"bytes,2,opt,name=Name,json=name" json:"Name,omitempty"`
	CPU        int32   `protobuf:"varint,3,opt,name=CPU,json=cPU" json:"CPU,omitempty"`
	RAM        float32 `protobuf:"fixed32,4,opt,name=RAM,json=rAM" json:"RAM,omitempty"`
	Disk       float32 `protobuf:"fixed32,5,opt,name=Disk,json=disk" json:"Disk,omitempty"`
	IP         string  `protobuf:"bytes,6,opt,name=IP,json=iP" json:"IP,omitempty"`
	State      VMState `protobuf:"varint,8,opt,name=State,json=state,enum=VMState" json:"State,omitempty"`
	PrivateKey string  `protobuf:"bytes,9,opt,name=PrivateKey,json=privateKey" json:"PrivateKey,omitempty"`
	GatewayID  string  `protobuf:"bytes,10,opt,name=GatewayID,json=gatewayID" json:"GatewayID,omitempty"`
}

func (m *VM) Reset()                    { *m = VM{} }
func (m *VM) String() string            { return proto.CompactTextString(m) }
func (*VM) ProtoMessage()               {}
func (*VM) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *VM) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *VM) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *VM) GetCPU() int32 {
	if m != nil {
		return m.CPU
	}
	return 0
}

func (m *VM) GetRAM() float32 {
	if m != nil {
		return m.RAM
	}
	return 0
}

func (m *VM) GetDisk() float32 {
	if m != nil {
		return m.Disk
	}
	return 0
}

func (m *VM) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

func (m *VM) GetState() VMState {
	if m != nil {
		return m.State
	}
	return VMState_STOPPED
}

func (m *VM) GetPrivateKey() string {
	if m != nil {
		return m.PrivateKey
	}
	return ""
}

func (m *VM) GetGatewayID() string {
	if m != nil {
		return m.GatewayID
	}
	return ""
}

type VMList struct {
	VMs []*VM `protobuf:"bytes,1,rep,name=VMs,json=vMs" json:"VMs,omitempty"`
}

func (m *VMList) Reset()                    { *m = VMList{} }
func (m *VMList) String() string            { return proto.CompactTextString(m) }
func (*VMList) ProtoMessage()               {}
func (*VMList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *VMList) GetVMs() []*VM {
	if m != nil {
		return m.VMs
	}
	return nil
}

type SshConfig struct {
	User       string     `protobuf:"bytes,1,opt,name=User,json=user" json:"User,omitempty"`
	Host       string     `protobuf:"bytes,2,opt,name=Host,json=host" json:"Host,omitempty"`
	PrivateKey string     `protobuf:"bytes,3,opt,name=PrivateKey,json=privateKey" json:"PrivateKey,omitempty"`
	Port       int32      `protobuf:"varint,4,opt,name=Port,json=port" json:"Port,omitempty"`
	Gateway    *SshConfig `protobuf:"bytes,5,opt,name=gateway" json:"gateway,omitempty"`
}

func (m *SshConfig) Reset()                    { *m = SshConfig{} }
func (m *SshConfig) String() string            { return proto.CompactTextString(m) }
func (*SshConfig) ProtoMessage()               {}
func (*SshConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *SshConfig) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *SshConfig) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *SshConfig) GetPrivateKey() string {
	if m != nil {
		return m.PrivateKey
	}
	return ""
}

func (m *SshConfig) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *SshConfig) GetGateway() *SshConfig {
	if m != nil {
		return m.Gateway
	}
	return nil
}

type VolumeDefinition struct {
	Tenant string      `protobuf:"bytes,1,opt,name=Tenant,json=tenant" json:"Tenant,omitempty"`
	Name   string      `protobuf:"bytes,2,opt,name=Name,json=name" json:"Name,omitempty"`
	Speed  VolumeSpeed `protobuf:"varint,3,opt,name=Speed,json=speed,enum=VolumeSpeed" json:"Speed,omitempty"`
	Size   int32       `protobuf:"varint,4,opt,name=Size,json=size" json:"Size,omitempty"`
}

func (m *VolumeDefinition) Reset()                    { *m = VolumeDefinition{} }
func (m *VolumeDefinition) String() string            { return proto.CompactTextString(m) }
func (*VolumeDefinition) ProtoMessage()               {}
func (*VolumeDefinition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *VolumeDefinition) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

func (m *VolumeDefinition) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *VolumeDefinition) GetSpeed() VolumeSpeed {
	if m != nil {
		return m.Speed
	}
	return VolumeSpeed_COLD
}

func (m *VolumeDefinition) GetSize() int32 {
	if m != nil {
		return m.Size
	}
	return 0
}

type Volume struct {
	ID    string      `protobuf:"bytes,1,opt,name=ID,json=iD" json:"ID,omitempty"`
	Name  string      `protobuf:"bytes,2,opt,name=Name,json=name" json:"Name,omitempty"`
	Speed VolumeSpeed `protobuf:"varint,3,opt,name=Speed,json=speed,enum=VolumeSpeed" json:"Speed,omitempty"`
	Size  int32       `protobuf:"varint,4,opt,name=Size,json=size" json:"Size,omitempty"`
}

func (m *Volume) Reset()                    { *m = Volume{} }
func (m *Volume) String() string            { return proto.CompactTextString(m) }
func (*Volume) ProtoMessage()               {}
func (*Volume) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *Volume) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Volume) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Volume) GetSpeed() VolumeSpeed {
	if m != nil {
		return m.Speed
	}
	return VolumeSpeed_COLD
}

func (m *Volume) GetSize() int32 {
	if m != nil {
		return m.Size
	}
	return 0
}

type VolumeList struct {
	Volumes []*Volume `protobuf:"bytes,1,rep,name=volumes" json:"volumes,omitempty"`
}

func (m *VolumeList) Reset()                    { *m = VolumeList{} }
func (m *VolumeList) String() string            { return proto.CompactTextString(m) }
func (*VolumeList) ProtoMessage()               {}
func (*VolumeList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *VolumeList) GetVolumes() []*Volume {
	if m != nil {
		return m.Volumes
	}
	return nil
}

type VolumeAttachment struct {
	Tenant    string     `protobuf:"bytes,1,opt,name=Tenant,json=tenant" json:"Tenant,omitempty"`
	Volume    *Reference `protobuf:"bytes,2,opt,name=Volume,json=volume" json:"Volume,omitempty"`
	VM        *Reference `protobuf:"bytes,3,opt,name=VM,json=vM" json:"VM,omitempty"`
	MountPath string     `protobuf:"bytes,4,opt,name=MountPath,json=mountPath" json:"MountPath,omitempty"`
	Format    string     `protobuf:"bytes,5,opt,name=Format,json=format" json:"Format,omitempty"`
}

func (m *VolumeAttachment) Reset()                    { *m = VolumeAttachment{} }
func (m *VolumeAttachment) String() string            { return proto.CompactTextString(m) }
func (*VolumeAttachment) ProtoMessage()               {}
func (*VolumeAttachment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *VolumeAttachment) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

func (m *VolumeAttachment) GetVolume() *Reference {
	if m != nil {
		return m.Volume
	}
	return nil
}

func (m *VolumeAttachment) GetVM() *Reference {
	if m != nil {
		return m.VM
	}
	return nil
}

func (m *VolumeAttachment) GetMountPath() string {
	if m != nil {
		return m.MountPath
	}
	return ""
}

func (m *VolumeAttachment) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

type VolumeDetachment struct {
	Volume *Reference `protobuf:"bytes,1,opt,name=Volume,json=volume" json:"Volume,omitempty"`
	VM     *Reference `protobuf:"bytes,2,opt,name=VM,json=vM" json:"VM,omitempty"`
}

func (m *VolumeDetachment) Reset()                    { *m = VolumeDetachment{} }
func (m *VolumeDetachment) String() string            { return proto.CompactTextString(m) }
func (*VolumeDetachment) ProtoMessage()               {}
func (*VolumeDetachment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *VolumeDetachment) GetVolume() *Reference {
	if m != nil {
		return m.Volume
	}
	return nil
}

func (m *VolumeDetachment) GetVM() *Reference {
	if m != nil {
		return m.VM
	}
	return nil
}

type Container struct {
	Tenant string `protobuf:"bytes,1,opt,name=Tenant,json=tenant" json:"Tenant,omitempty"`
	Name   string `protobuf:"bytes,2,opt,name=Name,json=name" json:"Name,omitempty"`
}

func (m *Container) Reset()                    { *m = Container{} }
func (m *Container) String() string            { return proto.CompactTextString(m) }
func (*Container) ProtoMessage()               {}
func (*Container) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *Container) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

func (m *Container) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type ContainerMountingPoint struct {
	Container string     `protobuf:"bytes,1,opt,name=Container,json=container" json:"Container,omitempty"`
	VM        *Reference `protobuf:"bytes,2,opt,name=VM,json=vM" json:"VM,omitempty"`
	Path      string     `protobuf:"bytes,3,opt,name=Path,json=path" json:"Path,omitempty"`
}

func (m *ContainerMountingPoint) Reset()                    { *m = ContainerMountingPoint{} }
func (m *ContainerMountingPoint) String() string            { return proto.CompactTextString(m) }
func (*ContainerMountingPoint) ProtoMessage()               {}
func (*ContainerMountingPoint) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *ContainerMountingPoint) GetContainer() string {
	if m != nil {
		return m.Container
	}
	return ""
}

func (m *ContainerMountingPoint) GetVM() *Reference {
	if m != nil {
		return m.VM
	}
	return nil
}

func (m *ContainerMountingPoint) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func init() {
	proto.RegisterType((*Empty)(nil), "Empty")
	proto.RegisterType((*Tenant)(nil), "Tenant")
	proto.RegisterType((*TenantList)(nil), "TenantList")
	proto.RegisterType((*Image)(nil), "Image")
	proto.RegisterType((*Reference)(nil), "Reference")
	proto.RegisterType((*TenantName)(nil), "TenantName")
	proto.RegisterType((*ImageList)(nil), "ImageList")
	proto.RegisterType((*NetworkDefinition)(nil), "NetworkDefinition")
	proto.RegisterType((*GatewayDefinition)(nil), "GatewayDefinition")
	proto.RegisterType((*Network)(nil), "Network")
	proto.RegisterType((*NetworkList)(nil), "NetworkList")
	proto.RegisterType((*VMDefinition)(nil), "VMDefinition")
	proto.RegisterType((*VM)(nil), "VM")
	proto.RegisterType((*VMList)(nil), "VMList")
	proto.RegisterType((*SshConfig)(nil), "SshConfig")
	proto.RegisterType((*VolumeDefinition)(nil), "VolumeDefinition")
	proto.RegisterType((*Volume)(nil), "Volume")
	proto.RegisterType((*VolumeList)(nil), "VolumeList")
	proto.RegisterType((*VolumeAttachment)(nil), "VolumeAttachment")
	proto.RegisterType((*VolumeDetachment)(nil), "VolumeDetachment")
	proto.RegisterType((*Container)(nil), "Container")
	proto.RegisterType((*ContainerMountingPoint)(nil), "ContainerMountingPoint")
	proto.RegisterEnum("VMState", VMState_name, VMState_value)
	proto.RegisterEnum("VolumeSpeed", VolumeSpeed_name, VolumeSpeed_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for TenantService service

type TenantServiceClient interface {
	List(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TenantList, error)
	Reload(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	Set(ctx context.Context, in *TenantName, opts ...grpc.CallOption) (*Empty, error)
	Get(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TenantName, error)
}

type tenantServiceClient struct {
	cc *grpc.ClientConn
}

func NewTenantServiceClient(cc *grpc.ClientConn) TenantServiceClient {
	return &tenantServiceClient{cc}
}

func (c *tenantServiceClient) List(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TenantList, error) {
	out := new(TenantList)
	err := grpc.Invoke(ctx, "/TenantService/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantServiceClient) Reload(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/TenantService/Reload", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantServiceClient) Set(ctx context.Context, in *TenantName, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/TenantService/Set", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantServiceClient) Get(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TenantName, error) {
	out := new(TenantName)
	err := grpc.Invoke(ctx, "/TenantService/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TenantService service

type TenantServiceServer interface {
	List(context.Context, *Empty) (*TenantList, error)
	Reload(context.Context, *Empty) (*Empty, error)
	Set(context.Context, *TenantName) (*Empty, error)
	Get(context.Context, *Empty) (*TenantName, error)
}

func RegisterTenantServiceServer(s *grpc.Server, srv TenantServiceServer) {
	s.RegisterService(&_TenantService_serviceDesc, srv)
}

func _TenantService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/TenantService/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServiceServer).List(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantService_Reload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServiceServer).Reload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/TenantService/Reload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServiceServer).Reload(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantService_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServiceServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/TenantService/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServiceServer).Set(ctx, req.(*TenantName))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/TenantService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServiceServer).Get(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _TenantService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "TenantService",
	HandlerType: (*TenantServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _TenantService_List_Handler,
		},
		{
			MethodName: "Reload",
			Handler:    _TenantService_Reload_Handler,
		},
		{
			MethodName: "Set",
			Handler:    _TenantService_Set_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _TenantService_Get_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "brokerd.proto",
}

// Client API for ImageService service

type ImageServiceClient interface {
	List(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*ImageList, error)
}

type imageServiceClient struct {
	cc *grpc.ClientConn
}

func NewImageServiceClient(cc *grpc.ClientConn) ImageServiceClient {
	return &imageServiceClient{cc}
}

func (c *imageServiceClient) List(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*ImageList, error) {
	out := new(ImageList)
	err := grpc.Invoke(ctx, "/ImageService/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ImageService service

type ImageServiceServer interface {
	List(context.Context, *Reference) (*ImageList, error)
}

func RegisterImageServiceServer(s *grpc.Server, srv ImageServiceServer) {
	s.RegisterService(&_ImageService_serviceDesc, srv)
}

func _ImageService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Reference)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ImageService/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).List(ctx, req.(*Reference))
	}
	return interceptor(ctx, in, info, handler)
}

var _ImageService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ImageService",
	HandlerType: (*ImageServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _ImageService_List_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "brokerd.proto",
}

// Client API for NetworkService service

type NetworkServiceClient interface {
	Create(ctx context.Context, in *NetworkDefinition, opts ...grpc.CallOption) (*Network, error)
	List(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NetworkList, error)
	Inspect(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*Network, error)
	Delete(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*Empty, error)
}

type networkServiceClient struct {
	cc *grpc.ClientConn
}

func NewNetworkServiceClient(cc *grpc.ClientConn) NetworkServiceClient {
	return &networkServiceClient{cc}
}

func (c *networkServiceClient) Create(ctx context.Context, in *NetworkDefinition, opts ...grpc.CallOption) (*Network, error) {
	out := new(Network)
	err := grpc.Invoke(ctx, "/NetworkService/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkServiceClient) List(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NetworkList, error) {
	out := new(NetworkList)
	err := grpc.Invoke(ctx, "/NetworkService/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkServiceClient) Inspect(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*Network, error) {
	out := new(Network)
	err := grpc.Invoke(ctx, "/NetworkService/Inspect", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkServiceClient) Delete(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/NetworkService/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for NetworkService service

type NetworkServiceServer interface {
	Create(context.Context, *NetworkDefinition) (*Network, error)
	List(context.Context, *Empty) (*NetworkList, error)
	Inspect(context.Context, *Reference) (*Network, error)
	Delete(context.Context, *Reference) (*Empty, error)
}

func RegisterNetworkServiceServer(s *grpc.Server, srv NetworkServiceServer) {
	s.RegisterService(&_NetworkService_serviceDesc, srv)
}

func _NetworkService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkDefinition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/NetworkService/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkServiceServer).Create(ctx, req.(*NetworkDefinition))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/NetworkService/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkServiceServer).List(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkService_Inspect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Reference)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkServiceServer).Inspect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/NetworkService/Inspect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkServiceServer).Inspect(ctx, req.(*Reference))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Reference)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/NetworkService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkServiceServer).Delete(ctx, req.(*Reference))
	}
	return interceptor(ctx, in, info, handler)
}

var _NetworkService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "NetworkService",
	HandlerType: (*NetworkServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _NetworkService_Create_Handler,
		},
		{
			MethodName: "List",
			Handler:    _NetworkService_List_Handler,
		},
		{
			MethodName: "Inspect",
			Handler:    _NetworkService_Inspect_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _NetworkService_Delete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "brokerd.proto",
}

// Client API for VMService service

type VMServiceClient interface {
	Create(ctx context.Context, in *VMDefinition, opts ...grpc.CallOption) (*VM, error)
	Inspect(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*VM, error)
	List(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*VMList, error)
	Delete(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*Empty, error)
	Ssh(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*SshConfig, error)
}

type vMServiceClient struct {
	cc *grpc.ClientConn
}

func NewVMServiceClient(cc *grpc.ClientConn) VMServiceClient {
	return &vMServiceClient{cc}
}

func (c *vMServiceClient) Create(ctx context.Context, in *VMDefinition, opts ...grpc.CallOption) (*VM, error) {
	out := new(VM)
	err := grpc.Invoke(ctx, "/VMService/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) Inspect(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*VM, error) {
	out := new(VM)
	err := grpc.Invoke(ctx, "/VMService/Inspect", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) List(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*VMList, error) {
	out := new(VMList)
	err := grpc.Invoke(ctx, "/VMService/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) Delete(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/VMService/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) Ssh(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*SshConfig, error) {
	out := new(SshConfig)
	err := grpc.Invoke(ctx, "/VMService/Ssh", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for VMService service

type VMServiceServer interface {
	Create(context.Context, *VMDefinition) (*VM, error)
	Inspect(context.Context, *Reference) (*VM, error)
	List(context.Context, *Empty) (*VMList, error)
	Delete(context.Context, *Reference) (*Empty, error)
	Ssh(context.Context, *Reference) (*SshConfig, error)
}

func RegisterVMServiceServer(s *grpc.Server, srv VMServiceServer) {
	s.RegisterService(&_VMService_serviceDesc, srv)
}

func _VMService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMDefinition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/VMService/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).Create(ctx, req.(*VMDefinition))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_Inspect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Reference)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).Inspect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/VMService/Inspect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).Inspect(ctx, req.(*Reference))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/VMService/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).List(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Reference)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/VMService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).Delete(ctx, req.(*Reference))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_Ssh_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Reference)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).Ssh(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/VMService/Ssh",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).Ssh(ctx, req.(*Reference))
	}
	return interceptor(ctx, in, info, handler)
}

var _VMService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "VMService",
	HandlerType: (*VMServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _VMService_Create_Handler,
		},
		{
			MethodName: "Inspect",
			Handler:    _VMService_Inspect_Handler,
		},
		{
			MethodName: "List",
			Handler:    _VMService_List_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _VMService_Delete_Handler,
		},
		{
			MethodName: "Ssh",
			Handler:    _VMService_Ssh_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "brokerd.proto",
}

// Client API for VolumeService service

type VolumeServiceClient interface {
	Create(ctx context.Context, in *VolumeDefinition, opts ...grpc.CallOption) (*Volume, error)
	Attach(ctx context.Context, in *VolumeAttachment, opts ...grpc.CallOption) (*Empty, error)
	Detach(ctx context.Context, in *VolumeDetachment, opts ...grpc.CallOption) (*Empty, error)
	Delete(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*Empty, error)
	List(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*VolumeList, error)
	Inspect(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*Volume, error)
}

type volumeServiceClient struct {
	cc *grpc.ClientConn
}

func NewVolumeServiceClient(cc *grpc.ClientConn) VolumeServiceClient {
	return &volumeServiceClient{cc}
}

func (c *volumeServiceClient) Create(ctx context.Context, in *VolumeDefinition, opts ...grpc.CallOption) (*Volume, error) {
	out := new(Volume)
	err := grpc.Invoke(ctx, "/VolumeService/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeServiceClient) Attach(ctx context.Context, in *VolumeAttachment, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/VolumeService/Attach", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeServiceClient) Detach(ctx context.Context, in *VolumeDetachment, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/VolumeService/Detach", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeServiceClient) Delete(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/VolumeService/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeServiceClient) List(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*VolumeList, error) {
	out := new(VolumeList)
	err := grpc.Invoke(ctx, "/VolumeService/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeServiceClient) Inspect(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*Volume, error) {
	out := new(Volume)
	err := grpc.Invoke(ctx, "/VolumeService/Inspect", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for VolumeService service

type VolumeServiceServer interface {
	Create(context.Context, *VolumeDefinition) (*Volume, error)
	Attach(context.Context, *VolumeAttachment) (*Empty, error)
	Detach(context.Context, *VolumeDetachment) (*Empty, error)
	Delete(context.Context, *Reference) (*Empty, error)
	List(context.Context, *Empty) (*VolumeList, error)
	Inspect(context.Context, *Reference) (*Volume, error)
}

func RegisterVolumeServiceServer(s *grpc.Server, srv VolumeServiceServer) {
	s.RegisterService(&_VolumeService_serviceDesc, srv)
}

func _VolumeService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VolumeDefinition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/VolumeService/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServiceServer).Create(ctx, req.(*VolumeDefinition))
	}
	return interceptor(ctx, in, info, handler)
}

func _VolumeService_Attach_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VolumeAttachment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServiceServer).Attach(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/VolumeService/Attach",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServiceServer).Attach(ctx, req.(*VolumeAttachment))
	}
	return interceptor(ctx, in, info, handler)
}

func _VolumeService_Detach_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VolumeDetachment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServiceServer).Detach(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/VolumeService/Detach",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServiceServer).Detach(ctx, req.(*VolumeDetachment))
	}
	return interceptor(ctx, in, info, handler)
}

func _VolumeService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Reference)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/VolumeService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServiceServer).Delete(ctx, req.(*Reference))
	}
	return interceptor(ctx, in, info, handler)
}

func _VolumeService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/VolumeService/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServiceServer).List(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VolumeService_Inspect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Reference)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServiceServer).Inspect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/VolumeService/Inspect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServiceServer).Inspect(ctx, req.(*Reference))
	}
	return interceptor(ctx, in, info, handler)
}

var _VolumeService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "VolumeService",
	HandlerType: (*VolumeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _VolumeService_Create_Handler,
		},
		{
			MethodName: "Attach",
			Handler:    _VolumeService_Attach_Handler,
		},
		{
			MethodName: "Detach",
			Handler:    _VolumeService_Detach_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _VolumeService_Delete_Handler,
		},
		{
			MethodName: "List",
			Handler:    _VolumeService_List_Handler,
		},
		{
			MethodName: "Inspect",
			Handler:    _VolumeService_Inspect_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "brokerd.proto",
}

// Client API for ContainerService service

type ContainerServiceClient interface {
	Create(ctx context.Context, in *Container, opts ...grpc.CallOption) (*Empty, error)
	Mount(ctx context.Context, in *ContainerMountingPoint, opts ...grpc.CallOption) (*Empty, error)
	UMount(ctx context.Context, in *ContainerMountingPoint, opts ...grpc.CallOption) (*Empty, error)
	Delete(ctx context.Context, in *Container, opts ...grpc.CallOption) (*Empty, error)
	List(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
}

type containerServiceClient struct {
	cc *grpc.ClientConn
}

func NewContainerServiceClient(cc *grpc.ClientConn) ContainerServiceClient {
	return &containerServiceClient{cc}
}

func (c *containerServiceClient) Create(ctx context.Context, in *Container, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/ContainerService/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *containerServiceClient) Mount(ctx context.Context, in *ContainerMountingPoint, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/ContainerService/Mount", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *containerServiceClient) UMount(ctx context.Context, in *ContainerMountingPoint, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/ContainerService/UMount", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *containerServiceClient) Delete(ctx context.Context, in *Container, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/ContainerService/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *containerServiceClient) List(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/ContainerService/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ContainerService service

type ContainerServiceServer interface {
	Create(context.Context, *Container) (*Empty, error)
	Mount(context.Context, *ContainerMountingPoint) (*Empty, error)
	UMount(context.Context, *ContainerMountingPoint) (*Empty, error)
	Delete(context.Context, *Container) (*Empty, error)
	List(context.Context, *Empty) (*Empty, error)
}

func RegisterContainerServiceServer(s *grpc.Server, srv ContainerServiceServer) {
	s.RegisterService(&_ContainerService_serviceDesc, srv)
}

func _ContainerService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Container)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContainerServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ContainerService/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContainerServiceServer).Create(ctx, req.(*Container))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContainerService_Mount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContainerMountingPoint)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContainerServiceServer).Mount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ContainerService/Mount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContainerServiceServer).Mount(ctx, req.(*ContainerMountingPoint))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContainerService_UMount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContainerMountingPoint)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContainerServiceServer).UMount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ContainerService/UMount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContainerServiceServer).UMount(ctx, req.(*ContainerMountingPoint))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContainerService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Container)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContainerServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ContainerService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContainerServiceServer).Delete(ctx, req.(*Container))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContainerService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContainerServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ContainerService/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContainerServiceServer).List(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _ContainerService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ContainerService",
	HandlerType: (*ContainerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _ContainerService_Create_Handler,
		},
		{
			MethodName: "Mount",
			Handler:    _ContainerService_Mount_Handler,
		},
		{
			MethodName: "UMount",
			Handler:    _ContainerService_UMount_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _ContainerService_Delete_Handler,
		},
		{
			MethodName: "List",
			Handler:    _ContainerService_List_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "brokerd.proto",
}

func init() { proto.RegisterFile("brokerd.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1197 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0xcf, 0x6e, 0xdb, 0x46,
	0x13, 0x17, 0x49, 0x91, 0x14, 0x47, 0xb2, 0xa1, 0x2c, 0xf0, 0xe5, 0x53, 0x85, 0xd4, 0x51, 0x17,
	0x4d, 0xe1, 0x26, 0x05, 0x53, 0x28, 0x87, 0xf6, 0x2a, 0x88, 0x8e, 0xa3, 0x26, 0xb4, 0x89, 0x95,
	0xa5, 0x3b, 0x2d, 0xad, 0x25, 0xc2, 0x16, 0xa9, 0x92, 0x2b, 0x05, 0xc9, 0xa9, 0xbd, 0x14, 0xe8,
	0xa1, 0x8f, 0x50, 0xa0, 0x97, 0x3e, 0x4a, 0xaf, 0x7d, 0x8c, 0x3e, 0x47, 0xb1, 0xcb, 0x5d, 0x8a,
	0xb2, 0xd4, 0xda, 0xf5, 0x89, 0x9a, 0x3f, 0x3b, 0xf3, 0x9b, 0xdf, 0xcc, 0x0e, 0x29, 0x38, 0xb8,
	0x4c, 0x93, 0x6b, 0x9a, 0x4e, 0xdd, 0x65, 0x9a, 0xb0, 0x04, 0xdb, 0x60, 0x9e, 0x2c, 0x96, 0xec,
	0x03, 0xfe, 0x16, 0xac, 0x0b, 0x1a, 0x87, 0x31, 0x43, 0x08, 0xaa, 0x67, 0xe1, 0x82, 0xb6, 0xb4,
	0x8e, 0x76, 0xec, 0x90, 0x6a, 0x1c, 0x2e, 0x28, 0x6a, 0x43, 0x2d, 0x48, 0x93, 0x75, 0x34, 0xa5,
	0x69, 0x4b, 0x17, 0xfa, 0xda, 0x52, 0xca, 0xf8, 0x25, 0x40, 0x7e, 0xf2, 0x5d, 0x94, 0x31, 0xf4,
	0x19, 0xd8, 0xb9, 0x94, 0xb5, 0xb4, 0x8e, 0x71, 0x5c, 0xef, 0xda, 0x6e, 0x2e, 0x13, 0x9b, 0xe5,
	0x7a, 0xfc, 0x02, 0xcc, 0xc1, 0x22, 0x9c, 0x51, 0x74, 0x08, 0xfa, 0xc0, 0x93, 0x79, 0xf4, 0xc8,
	0x2b, 0x32, 0xeb, 0x9b, 0xcc, 0xf8, 0x2d, 0x38, 0x84, 0x5e, 0xd1, 0x94, 0xc6, 0x13, 0x01, 0x23,
	0x0f, 0x56, 0x1c, 0xab, 0x31, 0x29, 0xcb, 0x60, 0xfa, 0x4e, 0x30, 0xa3, 0x14, 0xac, 0xa3, 0xa0,
	0x72, 0xcb, 0xbe, 0x42, 0xf1, 0x0b, 0x70, 0x04, 0x36, 0x51, 0xcb, 0x11, 0x58, 0x42, 0x50, 0xa5,
	0x58, 0xae, 0x10, 0x89, 0x15, 0x09, 0x2d, 0xfe, 0x51, 0x83, 0x47, 0x67, 0x94, 0xbd, 0x4f, 0xd2,
	0x6b, 0x8f, 0x5e, 0x45, 0x71, 0xc4, 0xa2, 0x24, 0x46, 0x8f, 0x15, 0x93, 0x32, 0xb0, 0xc5, 0xb6,
	0x79, 0x2d, 0x55, 0xc7, 0x75, 0xfd, 0x81, 0x47, 0x14, 0xc8, 0xc9, 0xc0, 0x23, 0xe8, 0x2b, 0xb0,
	0x4f, 0x43, 0x46, 0xdf, 0x87, 0x1f, 0x5a, 0xd5, 0x8e, 0x76, 0x5c, 0xef, 0x22, 0x57, 0xca, 0x9b,
	0x24, 0xc4, 0x9e, 0xe5, 0x2a, 0xfc, 0xb3, 0x06, 0x8f, 0x76, 0xcc, 0xa8, 0x09, 0x46, 0x3f, 0x18,
	0x09, 0x00, 0x26, 0x31, 0x26, 0xc1, 0x88, 0x6b, 0x48, 0xcf, 0x17, 0xc9, 0x75, 0x62, 0xa4, 0x3d,
	0x9f, 0xe7, 0xf6, 0xa2, 0xec, 0x5a, 0xe4, 0x36, 0x49, 0x75, 0x1a, 0x65, 0xd7, 0x08, 0x43, 0xa3,
	0x1f, 0x8c, 0x5e, 0xa7, 0xf4, 0xfb, 0x15, 0x8d, 0x27, 0x39, 0x00, 0x9d, 0x34, 0x26, 0x25, 0x1d,
	0x6a, 0x81, 0x2d, 0x68, 0x18, 0x78, 0x2d, 0x53, 0xc0, 0xb6, 0xa3, 0x5c, 0xc4, 0x3d, 0xb0, 0x25,
	0x1d, 0xf7, 0x69, 0xed, 0xbe, 0xe2, 0xf1, 0x2b, 0xa8, 0xcb, 0x10, 0xa2, 0x03, 0x9f, 0x43, 0x4d,
	0x8a, 0xaa, 0x07, 0x35, 0x57, 0x2a, 0x48, 0x2d, 0x96, 0x16, 0xfc, 0x83, 0x0e, 0x8d, 0xb1, 0xff,
	0xc0, 0x16, 0xb4, 0x0a, 0xd0, 0x12, 0x88, 0x2d, 0xe3, 0xa2, 0x27, 0xe0, 0xf4, 0x83, 0xd1, 0xd9,
	0x6a, 0x71, 0x49, 0x53, 0xc1, 0x84, 0x49, 0x9c, 0x89, 0x52, 0xec, 0x50, 0x65, 0xee, 0xa1, 0x4a,
	0x92, 0x6e, 0xed, 0x92, 0x6e, 0x0b, 0x55, 0x4e, 0x7a, 0x13, 0x8c, 0xd3, 0x60, 0xd4, 0xaa, 0x75,
	0xb4, 0xe3, 0x1a, 0x31, 0x66, 0xc1, 0xa8, 0x4c, 0xb1, 0xb3, 0x45, 0x31, 0xaf, 0x2c, 0x58, 0x5d,
	0xde, 0x44, 0x93, 0x16, 0x08, 0x77, 0x6b, 0x29, 0x24, 0xfc, 0xa7, 0x06, 0xfa, 0xd8, 0xbf, 0x17,
	0xed, 0x72, 0x36, 0x8c, 0x9d, 0xd9, 0xa8, 0xee, 0xc2, 0x34, 0x4b, 0x30, 0x79, 0xec, 0x40, 0xd4,
	0xc2, 0x63, 0x07, 0xe8, 0x08, 0xcc, 0x21, 0x0b, 0x19, 0x15, 0xc0, 0x0f, 0xbb, 0x35, 0x77, 0xec,
	0x0b, 0x99, 0x98, 0x19, 0x7f, 0xa0, 0x23, 0x80, 0x20, 0x8d, 0xd6, 0x21, 0xa3, 0x6f, 0xe9, 0x07,
	0x59, 0x07, 0x2c, 0x0b, 0x0d, 0xa7, 0x57, 0x0e, 0xee, 0xc0, 0x13, 0xd5, 0x38, 0xc4, 0x99, 0x29,
	0x05, 0x7e, 0x0a, 0xd6, 0xd8, 0x17, 0x33, 0xf0, 0x3f, 0x30, 0xc6, 0xbe, 0x6a, 0xbf, 0xe1, 0x8e,
	0x7d, 0x62, 0xac, 0xfd, 0x0c, 0xff, 0xa2, 0x81, 0x33, 0xcc, 0xe6, 0xfd, 0x24, 0xbe, 0x8a, 0x66,
	0x1c, 0xf0, 0x28, 0xa3, 0xa9, 0xba, 0xcb, 0xab, 0x8c, 0xa6, 0x5c, 0xf7, 0x26, 0xc9, 0x98, 0x2a,
	0x7e, 0x9e, 0x88, 0x2b, 0x5d, 0x06, 0x65, 0xec, 0x80, 0x42, 0x50, 0x0d, 0x92, 0x94, 0xc9, 0x76,
	0x57, 0x97, 0x49, 0xca, 0x87, 0x50, 0xdd, 0x36, 0xc1, 0x47, 0xbd, 0x0b, 0x6e, 0x91, 0x78, 0x73,
	0x11, 0xd7, 0xd0, 0x1c, 0x27, 0x37, 0xab, 0x05, 0x7d, 0xe0, 0x1c, 0x62, 0x30, 0x87, 0x4b, 0x4a,
	0xa7, 0x02, 0xd4, 0x61, 0xb7, 0xe1, 0xe6, 0xd1, 0x84, 0x8e, 0x98, 0x19, 0x7f, 0xf0, 0x73, 0xc3,
	0xe8, 0x23, 0x55, 0xe8, 0xb2, 0xe8, 0x23, 0xc5, 0x53, 0xb0, 0x72, 0xcf, 0x7b, 0x35, 0xff, 0xa1,
	0x59, 0x5e, 0x02, 0xe4, 0x9e, 0x6a, 0xc9, 0xaf, 0x85, 0xb4, 0x59, 0xf2, 0xb9, 0x95, 0x28, 0x3d,
	0xfe, 0x4d, 0x53, 0x7c, 0xf4, 0x18, 0x0b, 0x27, 0xf3, 0x05, 0x8d, 0xd9, 0x3f, 0xf2, 0x81, 0x55,
	0x0d, 0x02, 0x2b, 0x27, 0xb8, 0xd8, 0xf9, 0xc4, 0xca, 0x23, 0xa2, 0x36, 0x1f, 0x70, 0x01, 0x7b,
	0xdb, 0xae, 0xaf, 0x7d, 0x3e, 0x4a, 0x7e, 0xb2, 0x8a, 0x59, 0x10, 0xb2, 0xb9, 0x80, 0xed, 0x10,
	0x67, 0xa1, 0x14, 0x3c, 0xeb, 0xeb, 0x24, 0x5d, 0x84, 0x4c, 0xee, 0x2b, 0xeb, 0x4a, 0x48, 0x98,
	0x6c, 0x3a, 0x56, 0x20, 0xdc, 0x20, 0xd1, 0xee, 0x40, 0xa2, 0xef, 0x43, 0x82, 0xbf, 0x01, 0xa7,
	0x9f, 0xc4, 0x2c, 0x8c, 0x62, 0x9a, 0xfe, 0x97, 0xf6, 0xe3, 0x2b, 0x78, 0x5c, 0x1c, 0x14, 0xb5,
	0x44, 0xf1, 0x2c, 0x48, 0xa2, 0x98, 0x89, 0x35, 0xa4, 0x2c, 0x32, 0x90, 0x33, 0x29, 0x72, 0xfc,
	0x0b, 0x18, 0x31, 0xcc, 0x9c, 0x11, 0xb9, 0x60, 0x97, 0x21, 0x9b, 0x3f, 0xff, 0x0e, 0x6c, 0x79,
	0x4f, 0x51, 0x1d, 0xec, 0xe1, 0xc5, 0x79, 0x10, 0x9c, 0x78, 0xcd, 0x0a, 0x6a, 0x40, 0x6d, 0x78,
	0xd1, 0x23, 0x17, 0x83, 0xb3, 0xd3, 0xa6, 0x96, 0x9b, 0x7a, 0xe4, 0xe2, 0xc4, 0x6b, 0xea, 0xb9,
	0xe9, 0x3c, 0x08, 0xb8, 0xc9, 0x40, 0x0e, 0x98, 0x27, 0x84, 0x9c, 0x93, 0x66, 0xf5, 0xf9, 0x97,
	0x50, 0x2f, 0x8d, 0x0f, 0xaa, 0x41, 0xb5, 0x7f, 0xfe, 0x8e, 0x07, 0xb3, 0xc1, 0x78, 0xe3, 0x79,
	0x4d, 0x8d, 0xff, 0x18, 0x0e, 0xbd, 0xa6, 0xde, 0xfd, 0x49, 0x83, 0x83, 0x9c, 0x8b, 0x21, 0x4d,
	0xd7, 0xd1, 0x84, 0xa2, 0x4f, 0xa1, 0x2a, 0x66, 0xc9, 0x72, 0xc5, 0x07, 0x48, 0xbb, 0xee, 0x6e,
	0xbe, 0x22, 0x70, 0x05, 0xb5, 0xc1, 0x22, 0xf4, 0x26, 0x09, 0xa7, 0x85, 0x83, 0x7c, 0xe2, 0x0a,
	0x7a, 0x02, 0xc6, 0x90, 0x32, 0xa4, 0x4e, 0x70, 0x2e, 0xb7, 0xad, 0xa7, 0x74, 0x37, 0x2e, 0xf7,
	0xc2, 0x95, 0xee, 0xd7, 0xd0, 0x10, 0xab, 0x55, 0xc1, 0xe8, 0x48, 0x18, 0x25, 0xee, 0xda, 0xe0,
	0x16, 0xdf, 0x00, 0xb8, 0xd2, 0xfd, 0x55, 0x83, 0x43, 0xf9, 0x86, 0x50, 0x87, 0x8e, 0xc1, 0xea,
	0xa7, 0x94, 0x73, 0x88, 0xdc, 0x9d, 0x0f, 0x80, 0x76, 0xf1, 0x8a, 0xc2, 0x15, 0x74, 0x74, 0xab,
	0xca, 0x86, 0x5b, 0x7a, 0xbd, 0xe1, 0x0a, 0xbf, 0x49, 0x83, 0x38, 0x5b, 0xd2, 0xc9, 0x36, 0x82,
	0xed, 0x10, 0x96, 0x47, 0x6f, 0x28, 0xa3, 0x5b, 0x1e, 0x45, 0xbd, 0xdd, 0xdf, 0x35, 0x70, 0xc6,
	0xbe, 0x82, 0x76, 0x54, 0x40, 0x3b, 0x70, 0xcb, 0xef, 0xc4, 0x36, 0xdf, 0x9c, 0x82, 0x9d, 0xbd,
	0x09, 0xa5, 0xf5, 0x93, 0x5b, 0x70, 0x6d, 0x37, 0x5f, 0xc2, 0x77, 0xc3, 0x40, 0x4f, 0xc1, 0x18,
	0x66, 0xf3, 0x5b, 0x3c, 0x16, 0x7b, 0x12, 0x57, 0xba, 0x7f, 0x69, 0x70, 0x20, 0xc7, 0x45, 0x62,
	0xfd, 0xa2, 0xc0, 0xfa, 0xc8, 0xbd, 0xbd, 0x3b, 0xdb, 0x6a, 0xa5, 0xe0, 0x0a, 0x7a, 0x06, 0x56,
	0xbe, 0x44, 0x0a, 0xbf, 0xcd, 0x4e, 0x29, 0x21, 0x78, 0xc6, 0x11, 0x6e, 0xb9, 0x6d, 0x2e, 0x76,
	0xc9, 0xed, 0xae, 0x42, 0x76, 0x07, 0x73, 0xb3, 0xf9, 0x70, 0x05, 0x75, 0xf6, 0x13, 0xb8, 0x81,
	0xdb, 0xfd, 0x43, 0x83, 0x66, 0x71, 0x63, 0x77, 0xfb, 0x02, 0x6e, 0x61, 0x2c, 0x65, 0x7d, 0x0e,
	0xa6, 0xb8, 0xf6, 0xe8, 0xff, 0xee, 0xfe, 0x3d, 0x50, 0xf2, 0x7d, 0x01, 0xd6, 0xe8, 0xde, 0xce,
	0xe5, 0x72, 0xf7, 0x25, 0x6e, 0xdd, 0x2a, 0xb7, 0xb0, 0x5c, 0x5a, 0xe2, 0x2f, 0xc2, 0xab, 0xbf,
	0x03, 0x00, 0x00, 0xff, 0xff, 0x02, 0xee, 0xae, 0x38, 0x33, 0x0c, 0x00, 0x00,
}
